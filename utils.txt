Project Path: utils

Source Tree:

```
utils
├── part.ts
├── errors.d.ts
├── errors.ts
├── message.ts
├── artifact.ts
└── task.ts

```

`/Users/hra/Workspace/Code/tesser/front-agent/packages/sdk/src/utils/part.ts`:

```ts
import type {
  TextPart,
  FilePart,
  DataPart,
  FileWithBytes,
  FileWithUri,
} from "../types/types.js";

/**
 * Creates a text part with the given content and metadata
 */
export function createTextPart(
  text: string,
  metadata?: Record<string, any>
): TextPart {
  return {
    kind: "text",
    text,
    ...(metadata && { metadata }),
  };
}

/**
 * Creates a file part with the given file data and metadata
 */
export function createFilePart(
  file: FileWithBytes | FileWithUri,
  metadata?: Record<string, any>
): FilePart {
  return {
    kind: "file",
    file,
    ...(metadata && { metadata }),
  };
}

export function isFileWithBytes(
  file: FileWithBytes | FileWithUri
): file is FileWithBytes {
  return "bytes" in file;
}

export function isFileWithUri(
  file: FileWithBytes | FileWithUri
): file is FileWithUri {
  return "uri" in file;
}

/**
 * Creates a data part with the given data and metadata
 */
export function createDataPart(
  data: Record<string, any>,
  metadata?: Record<string, any>
): DataPart {
  return {
    kind: "data",
    data,
    ...(metadata && { metadata }),
  };
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/packages/sdk/src/utils/errors.d.ts`:

```ts
import { JSONRPCError } from "../types/types.ts";
export declare function jsonParseError(message?: string, data?: unknown): JSONRPCError;
export declare function invalidRequestError(message?: string, data?: unknown): JSONRPCError;
export declare function methodNotFoundError(message?: string, data?: unknown): JSONRPCError;
export declare function invalidParamsError(message?: string, data?: unknown): JSONRPCError;
export declare function internalError(message?: string, data?: unknown): JSONRPCError;
export declare function taskNotFoundError(message?: string, data?: unknown): JSONRPCError;
export declare function taskNotCancelableError(message?: string, data?: unknown): JSONRPCError;
export declare function pushNotificationNotSupportedError(message?: string, data?: unknown): JSONRPCError;
export declare function unsupportedOperationError(message?: string, data?: unknown): JSONRPCError;
export declare function contentTypeNotSupportedError(message?: string, data?: unknown): JSONRPCError;
export declare function invalidAgentResponseError(message?: string, data?: unknown): JSONRPCError;

```

`/Users/hra/Workspace/Code/tesser/front-agent/packages/sdk/src/utils/errors.ts`:

```ts
import { ErrorType } from "../types/types.ts";
import { JSONRPCError } from "../types/types.ts";

//---------- JSONRPC Errors ----------
export function jsonParseError(message?: string, data?: unknown): JSONRPCError {
  return {
    code: ErrorType.JSONParseError,
    message: message ?? "Invalid JSON payload",
    data,
  };
}

export function invalidRequestError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.InvalidRequestError,
    message: message ?? "Request payload validation error",
    data,
  };
}

export function methodNotFoundError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.MethodNotFoundError,
    message: message ?? "Method not found",
    data,
  };
}

export function invalidParamsError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.InvalidParamsError,
    message: message ?? "Invalid parameters",
    data,
  };
}

export function internalError(message?: string, data?: unknown): JSONRPCError {
  return {
    code: ErrorType.InternalError,
    message: message ?? "Internal error",
    data,
  };
}

//---------- A2A Errors ----------

export function taskNotFoundError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.TaskNotFoundError,
    message: message ?? "Task not found",
    data,
  };
}

export function taskNotCancelableError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.TaskNotCancelableError,
    message: message ?? "Task cannot be canceled",
    data,
  };
}

export function pushNotificationNotSupportedError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.PushNotificationNotSupportedError,
    message: message ?? "Push Notification is not supported",
    data,
  };
}

export function unsupportedOperationError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.UnsupportedOperationError,
    message: message ?? "This operation is not supported",
    data,
  };
}

export function contentTypeNotSupportedError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.ContentTypeNotSupportedError,
    message: message ?? "Incompatible content types",
    data,
  };
}

export function invalidAgentResponseError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.InvalidAgentResponseError,
    message: message ?? "Invalid agent response",
    data,
  };
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/packages/sdk/src/utils/message.ts`:

```ts
import { v4 as uuidv4 } from "uuid";
import {
  Message,
  MessageRole,
  Part,
  Task,
  FileWithBytes,
  FileWithUri,
  FilePart,
  TextPart,
  DataPart,
} from "../types/types.ts";

export class MessageHandler {
  private message: Message;

  constructor(baseMessage?: Partial<Message>) {
    this.message = {
      kind: "message",
      messageId: baseMessage?.messageId || uuidv4(),
      role: baseMessage?.role || "user",
      parts: baseMessage?.parts ? [...baseMessage.parts] : [],
    };
  }

  withId(messageId: string): MessageHandler {
    this.message.messageId = messageId;
    return this;
  }

  withRole(role: MessageRole): MessageHandler {
    this.message.role = role;
    return this;
  }

  inResponseTo(source: Task | Message): MessageHandler {
    if (source.kind === "task") {
      // Set context and task ID from a Task
      this.message.contextId = source.contextId;
      this.message.taskId = source.id;
    } else if (source.kind === "message") {
      // Set context, task ID, and inResponseTo from a Message
      this.message.contextId = source.contextId;
      this.message.taskId = source.taskId;
    }
    return this;
  }

  withContextId(contextId: string): MessageHandler {
    this.message.contextId = contextId;
    return this;
  }

  withParts(parts: Part[]): MessageHandler {
    this.message.parts = [...parts];
    return this;
  }

  addParts(parts: Part[]): MessageHandler {
    this.message.parts.push(...parts);
    return this;
  }

  addTextPart(text: string, metadata?: Record<string, any>): MessageHandler {
    this.message.parts.push({
      kind: "text",
      text,
      ...(metadata && { metadata }),
    });
    return this;
  }

  addFilePart(
    file: FileWithBytes | FileWithUri,
    metadata?: Record<string, any>
  ): MessageHandler {
    this.message.parts.push({
      kind: "file",
      file,
      ...(metadata && { metadata }),
    });
    return this;
  }

  addDataPart(data: any, metadata?: Record<string, any>): MessageHandler {
    this.message.parts.push({
      kind: "data",
      data,
      ...(metadata && { metadata }),
    });
    return this;
  }

  clearParts(): MessageHandler {
    this.message.parts = [];
    return this;
  }

  withMetadata(metadata: Record<string, any>): MessageHandler {
    this.message.metadata = {
      ...this.message.metadata,
      ...metadata,
    };
    return this;
  }

  getMessage(): Message {
    return { ...this.message };
  }

  getTextParts(): TextPart[] {
    return this.message.parts.filter(
      (
        part
      ): part is {
        kind: "text";
        text: string;
        metadata?: Record<string, any>;
      } => part.kind === "text"
    );
  }

  getText(): string {
    return this.getTextParts()
      .map((part) => part.text)
      .join("\n");
  }

  getFileParts(): FilePart[] {
    return this.message.parts.filter(
      (
        part
      ): part is {
        kind: "file";
        file: FileWithBytes | FileWithUri;
        metadata?: Record<string, any>;
      } => part.kind === "file"
    );
  }

  getFiles(): Array<FileWithBytes | FileWithUri> {
    return this.getFileParts().map((part) => part.file);
  }

  getDataParts(): DataPart[] {
    return this.message.parts.filter(
      (
        part
      ): part is {
        kind: "data";
        data: any;
        metadata?: Record<string, any>;
      } => part.kind === "data"
    );
  }

  getData(): Record<string, any> {
    return this.getDataParts().map((part) => part.data);
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/packages/sdk/src/utils/artifact.ts`:

```ts
import type {
  Artifact,
  Part,
  FileWithBytes,
  FileWithUri,
  FilePart,
  DataPart,
  TextPart,
} from "../types/types.js";

import { v4 as uuidv4 } from "uuid";

export class ArtifactHandler {
  private artifact: Artifact;

  constructor(base?: Partial<Artifact> | Artifact) {
    this.artifact = {
      artifactId: base?.artifactId || uuidv4(),
      name: base?.name,
      description: base?.description,
      metadata: base?.metadata,
      parts: base?.parts || [],
    };
  }

  withId(artifactId: string): ArtifactHandler {
    this.artifact.artifactId = artifactId;
    return this;
  }

  withName(name: string): ArtifactHandler {
    this.artifact.name = name;
    return this;
  }

  withDescription(description: string): ArtifactHandler {
    this.artifact.description = description;
    return this;
  }

  withParts(parts: Part[]): ArtifactHandler {
    this.artifact.parts = [...parts];
    return this;
  }

  addParts(parts: Part[]): ArtifactHandler {
    this.artifact.parts.push(...parts);
    return this;
  }

  clearParts(): ArtifactHandler {
    this.artifact.parts = [];
    return this;
  }

  withMetadata(metadata: Record<string, any>): ArtifactHandler {
    this.artifact.metadata = metadata;
    return this;
  }

  getArtifact(): Artifact {
    return { ...this.artifact };
  }

  getParts(): Part[] {
    return [...this.artifact.parts];
  }

  getTextParts(): Array<TextPart> {
    return this.artifact.parts.filter(
      (part: Part): part is TextPart => part.kind === "text"
    );
  }

  getFileParts(): Array<FilePart> {
    return this.artifact.parts.filter(
      (part: Part): part is FilePart => part.kind === "file"
    );
  }

  getDataParts(): Array<DataPart> {
    return this.artifact.parts.filter(
      (part: Part): part is DataPart => part.kind === "data"
    );
  }

  // Static factory methods
  static fromText(
    text: string,
    metadata?: Record<string, any>
  ): ArtifactHandler {
    return new ArtifactHandler({
      parts: [
        {
          kind: "text",
          text,
          metadata,
        },
      ],
    });
  }

  static fromFile(
    file: FileWithBytes | FileWithUri,
    metadata?: Record<string, any>
  ): ArtifactHandler {
    const name = (file as any).name || "file-artifact";
    return new ArtifactHandler({
      name,
      parts: [
        {
          kind: "file",
          file,
          metadata,
        },
      ],
    });
  }

  static fromData(data: any, metadata?: Record<string, any>): ArtifactHandler {
    return new ArtifactHandler({
      parts: [
        {
          kind: "data",
          data,
          metadata,
        },
      ],
    });
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/packages/sdk/src/utils/task.ts`:

```ts
import { v4 as uuidv4 } from "uuid";
import {
  Task,
  TaskStatus,
  Artifact,
  Message,
  TaskStatusUpdateEvent,
  TaskArtifactUpdateEvent,
  TaskState,
  TaskSchema,
} from "../types/types.js";

export class TaskHandler {
  private task: Partial<Task>;

  constructor(baseTask?: Partial<Omit<Task, "kind">>) {
    this.task = {
      id: baseTask?.id || uuidv4(),
      kind: "task",
      contextId: baseTask?.contextId || undefined,
      status: baseTask?.status
        ? { ...baseTask.status }
        : {
            state: "submitted" as TaskState,
            timestamp: new Date().toISOString(),
          },
      artifacts: baseTask?.artifacts ? [...baseTask.artifacts] : [],
      history: baseTask?.history ? [...baseTask.history] : [],
      metadata: baseTask?.metadata ? { ...baseTask.metadata } : {},
    };
  }

  withId(id: string): TaskHandler {
    this.task.id = id;
    return this;
  }

  withContextId(contextId: string): TaskHandler {
    this.task.contextId = contextId;
    return this;
  }

  withStatus(status: TaskStatus): TaskHandler {
    this.task.status = {
      ...status,
      timestamp: status.timestamp || new Date().toISOString(),
    };
    // update message taskId and contextId if message is set
    if (status.message) {
      this.task.status.message = {
        ...status.message,
        taskId: this.task.id,
        contextId: this.task.contextId,
      };
    }

    return this;
  }

  handleStatusUpdate(event: TaskStatusUpdateEvent): TaskHandler {
    if (event.taskId !== this.task.id) {
      throw new Error(
        `Task ID mismatch for status update: expected ${this.task.id}, got ${event.taskId}`
      );
    }

    return this.withStatus({
      ...event.status,
    });
  }

  withArtifacts(artifacts: Artifact[]): TaskHandler {
    this.task.artifacts = [...artifacts];
    return this;
  }

  upsertArtifact(artifact: Artifact, append: boolean = false): TaskHandler {
    if (!this.task.artifacts) {
      this.task.artifacts = [];
    }

    const existingIndex = this.task.artifacts.findIndex(
      (a: Artifact) => a.artifactId === artifact.artifactId
    );

    // ToDo: find out how the artifacts parts are aggregated if an artifacts has multimodal parts with chunks.
    if (existingIndex !== -1) {
      if (append) {
        this.task.artifacts[existingIndex].parts.push(...artifact.parts);
      } else {
        this.task.artifacts[existingIndex] = artifact;
      }
    } else {
      this.task.artifacts.push(artifact);
    }
    return this;
  }

  handleArtifactUpdate(event: TaskArtifactUpdateEvent): TaskHandler {
    if (event.taskId !== this.task.id) return this;
    return this.upsertArtifact(event.artifact, event.append);
  }

  withMetadata(metadata: Record<string, any>): TaskHandler {
    this.task.metadata = metadata;
    return this;
  }

  withHistory(messages: Message[]): TaskHandler {
    this.task.history = [...messages];
    return this;
  }

  addMessageToHistory(message: Message): TaskHandler {
    if (!this.task.history) {
      this.task.history = [];
    }
    this.task.history.push(message);
    return this;
  }

  getTask(): Task {
    if (!this.task.contextId) {
      throw new Error("Context ID is required for task");
    }
    return TaskSchema.parse(this.task);
  }
}

```