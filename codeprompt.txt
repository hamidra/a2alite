Project Path: src

Source Tree:

```
src
├── types
│   ├── errors.ts
│   ├── a2a.json
│   └── types.ts
├── server
│   ├── notification
│   │   └── index.ts
│   ├── providers
│   │   ├── storage
│   │   │   ├── in_memory.ts
│   │   │   └── index.ts
│   │   └── queue
│   │       ├── in_memory.ts
│   │       └── queue.ts
│   ├── agent
│   │   ├── executor.ts
│   │   ├── context.ts
│   │   ├── stream.ts
│   │   ├── types.ts
│   │   └── request.ts
│   ├── http
│   │   └── hono
│   │       └── hono.ts
│   ├── taskStreamConsumer.ts
│   └── index.ts
├── utils
│   ├── part.ts
│   ├── errors.ts
│   ├── message.ts
│   ├── artifact.ts
│   └── task.ts
├── shared
│   ├── jsonRpcBodyParser.ts
│   └── jsonRpcServer.ts
├── examples
│   ├── langchainAgent
│   ├── echoStreamAgent
│   │   ├── client.ts
│   │   └── server.ts
│   └── echoAgent
│       ├── client.ts
│       └── server.ts
└── client
    ├── a2aClient.ts
    └── curl.requests

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/types/errors.ts`:

```ts
/**
 * Custom error for general JSON parsing failures
 */
export class JSONParseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "JSONParseError";
    // Ensure proper stack trace in V8 engines
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, JSONParseError);
    }
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/types/a2a.json`:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "A2AError": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONParseError"
        },
        {
          "$ref": "#/definitions/InvalidRequestError"
        },
        {
          "$ref": "#/definitions/MethodNotFoundError"
        },
        {
          "$ref": "#/definitions/InvalidParamsError"
        },
        {
          "$ref": "#/definitions/InternalError"
        },
        {
          "$ref": "#/definitions/TaskNotFoundError"
        },
        {
          "$ref": "#/definitions/TaskNotCancelableError"
        },
        {
          "$ref": "#/definitions/PushNotificationNotSupportedError"
        },
        {
          "$ref": "#/definitions/UnsupportedOperationError"
        },
        {
          "$ref": "#/definitions/ContentTypeNotSupportedError"
        },
        {
          "$ref": "#/definitions/InvalidAgentResponseError"
        }
      ]
    },
    "A2ARequest": {
      "anyOf": [
        {
          "$ref": "#/definitions/SendMessageRequest"
        },
        {
          "$ref": "#/definitions/SendStreamingMessageRequest"
        },
        {
          "$ref": "#/definitions/GetTaskRequest"
        },
        {
          "$ref": "#/definitions/CancelTaskRequest"
        },
        {
          "$ref": "#/definitions/SetTaskPushNotificationConfigRequest"
        },
        {
          "$ref": "#/definitions/GetTaskPushNotificationConfigRequest"
        },
        {
          "$ref": "#/definitions/TaskResubscriptionRequest"
        }
      ],
      "description": "A2A supported request types"
    },
    "APIKeySecurityScheme": {
      "description": "API Key security scheme.",
      "properties": {
        "description": {
          "description": "Description of this security scheme.",
          "type": "string"
        },
        "in": {
          "description": "The location of the API key. Valid values are \"query\", \"header\", or \"cookie\".",
          "enum": ["cookie", "header", "query"],
          "type": "string"
        },
        "name": {
          "description": "The name of the header, query or cookie parameter to be used.",
          "type": "string"
        },
        "type": {
          "const": "apiKey",
          "type": "string"
        }
      },
      "required": ["in", "name", "type"],
      "type": "object"
    },
    "AgentCapabilities": {
      "description": "Defines optional capabilities supported by an agent.",
      "properties": {
        "pushNotifications": {
          "description": "true if the agent can notify updates to client.",
          "type": "boolean"
        },
        "stateTransitionHistory": {
          "description": "true if the agent exposes status change history for tasks.",
          "type": "boolean"
        },
        "streaming": {
          "description": "true if the agent supports SSE.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "AgentCard": {
      "description": "An AgentCard conveys key information:\n- Overall details (version, name, description, uses)\n- Skills: A set of capabilities the agent can perform\n- Default modalities/content types supported by the agent.\n- Authentication requirements",
      "properties": {
        "capabilities": {
          "$ref": "#/definitions/AgentCapabilities",
          "description": "Optional capabilities supported by the agent."
        },
        "defaultInputModes": {
          "description": "The set of interaction modes that the agent supports across all skills. This can be overridden per-skill.\nSupported mime types for input.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "defaultOutputModes": {
          "description": "Supported mime types for output.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "description": {
          "description": "A human-readable description of the agent. Used to assist users and\nother agents in understanding what the agent can do.",
          "type": "string"
        },
        "documentationUrl": {
          "description": "A URL to documentation for the agent.",
          "type": "string"
        },
        "name": {
          "description": "Human readable name of the agent.",
          "type": "string"
        },
        "provider": {
          "$ref": "#/definitions/AgentProvider",
          "description": "The service provider of the agent"
        },
        "security": {
          "description": "Security requirements for contacting the agent.",
          "items": {
            "additionalProperties": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "object"
          },
          "type": "array"
        },
        "securitySchemes": {
          "additionalProperties": {
            "$ref": "#/definitions/SecurityScheme"
          },
          "description": "Security scheme details used for authenticating with this agent.",
          "type": "object"
        },
        "skills": {
          "description": "Skills are a unit of capability that an agent can perform.",
          "items": {
            "$ref": "#/definitions/AgentSkill"
          },
          "type": "array"
        },
        "supportsAuthenticatedExtendedCard": {
          "description": "true if the agent supports providing an extended agent card when the user is authenticated.\nDefaults to false if not specified.",
          "type": "boolean"
        },
        "url": {
          "description": "A URL to the address the agent is hosted at.",
          "type": "string"
        },
        "version": {
          "description": "The version of the agent - format is up to the provider.",
          "type": "string"
        }
      },
      "required": [
        "capabilities",
        "defaultInputModes",
        "defaultOutputModes",
        "description",
        "name",
        "skills",
        "url",
        "version"
      ],
      "type": "object"
    },
    "AgentProvider": {
      "description": "Represents the service provider of an agent.",
      "properties": {
        "organization": {
          "description": "Agent provider's organization name.",
          "type": "string"
        },
        "url": {
          "description": "Agent provider's URL.",
          "type": "string"
        }
      },
      "required": ["organization", "url"],
      "type": "object"
    },
    "AgentSkill": {
      "description": "Represents a unit of capability that an agent can perform.",
      "properties": {
        "description": {
          "description": "Description of the skill - will be used by the client or a human\nas a hint to understand what the skill does.",
          "type": "string"
        },
        "examples": {
          "description": "The set of example scenarios that the skill can perform.\nWill be used by the client as a hint to understand how the skill can be used.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "id": {
          "description": "Unique identifier for the agent's skill.",
          "type": "string"
        },
        "inputModes": {
          "description": "The set of interaction modes that the skill supports\n(if different than the default).\nSupported mime types for input.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "name": {
          "description": "Human readable name of the skill.",
          "type": "string"
        },
        "outputModes": {
          "description": "Supported mime types for output.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "tags": {
          "description": "Set of tagwords describing classes of capabilities for this specific skill.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": ["description", "id", "name", "tags"],
      "type": "object"
    },
    "Artifact": {
      "description": "Represents an artifact generated for a task.",
      "properties": {
        "artifactId": {
          "description": "Unique identifier for the artifact.",
          "type": "string"
        },
        "description": {
          "description": "Optional description for the artifact.",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Extension metadata.",
          "type": "object"
        },
        "name": {
          "description": "Optional name for the artifact.",
          "type": "string"
        },
        "parts": {
          "description": "Artifact parts.",
          "items": {
            "$ref": "#/definitions/Part"
          },
          "type": "array"
        }
      },
      "required": ["artifactId", "parts"],
      "type": "object"
    },
    "AuthorizationCodeOAuthFlow": {
      "description": "Configuration details for a supported OAuth Flow",
      "properties": {
        "authorizationUrl": {
          "description": "The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS",
          "type": "string"
        },
        "refreshUrl": {
          "description": "The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS.",
          "type": "string"
        },
        "scopes": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "The available scopes for the OAuth2 security scheme. A map between the scope name and a short\ndescription for it. The map MAY be empty.",
          "type": "object"
        },
        "tokenUrl": {
          "description": "The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard\nrequires the use of TLS.",
          "type": "string"
        }
      },
      "required": ["authorizationUrl", "scopes", "tokenUrl"],
      "type": "object"
    },
    "CancelTaskRequest": {
      "description": "JSON-RPC request model for the 'tasks/cancel' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "method": {
          "const": "tasks/cancel",
          "description": "A String containing the name of the method to be invoked.",
          "type": "string"
        },
        "params": {
          "$ref": "#/definitions/TaskIdParams",
          "description": "A Structured value that holds the parameter values to be used during the invocation of the method."
        }
      },
      "required": ["jsonrpc", "method", "params"],
      "type": "object"
    },
    "CancelTaskResponse": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONRPCErrorResponse"
        },
        {
          "$ref": "#/definitions/CancelTaskSuccessResponse"
        }
      ],
      "description": "JSON-RPC response for the 'tasks/cancel' method."
    },
    "CancelTaskSuccessResponse": {
      "description": "JSON-RPC success response model for the 'tasks/cancel' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/Task",
          "description": "The result object on success."
        }
      },
      "required": ["jsonrpc", "result"],
      "type": "object"
    },
    "ClientCredentialsOAuthFlow": {
      "description": "Configuration details for a supported OAuth Flow",
      "properties": {
        "refreshUrl": {
          "description": "The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS.",
          "type": "string"
        },
        "scopes": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "The available scopes for the OAuth2 security scheme. A map between the scope name and a short\ndescription for it. The map MAY be empty.",
          "type": "object"
        },
        "tokenUrl": {
          "description": "The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard\nrequires the use of TLS.",
          "type": "string"
        }
      },
      "required": ["scopes", "tokenUrl"],
      "type": "object"
    },
    "ContentTypeNotSupportedError": {
      "description": "A2A specific error indicating incompatible content types between request and agent capabilities.",
      "properties": {
        "code": {
          "const": -32005,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Incompatible content types",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "DataPart": {
      "description": "Represents a structured data segment within a message part.",
      "properties": {
        "data": {
          "additionalProperties": {},
          "description": "Structured data content",
          "type": "object"
        },
        "kind": {
          "const": "data",
          "description": "Part type - data for DataParts",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Optional metadata associated with the part.",
          "type": "object"
        }
      },
      "required": ["data", "kind"],
      "type": "object"
    },
    "FileBase": {
      "description": "Represents the base entity for FileParts",
      "properties": {
        "mimeType": {
          "description": "Optional mimeType for the file",
          "type": "string"
        },
        "name": {
          "description": "Optional name for the file",
          "type": "string"
        }
      },
      "type": "object"
    },
    "FilePart": {
      "description": "Represents a File segment within parts.",
      "properties": {
        "file": {
          "anyOf": [
            {
              "$ref": "#/definitions/FileWithBytes"
            },
            {
              "$ref": "#/definitions/FileWithUri"
            }
          ],
          "description": "File content either as url or bytes"
        },
        "kind": {
          "const": "file",
          "description": "Part type - file for FileParts",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Optional metadata associated with the part.",
          "type": "object"
        }
      },
      "required": ["file", "kind"],
      "type": "object"
    },
    "FileWithBytes": {
      "description": "Define the variant where 'bytes' is present and 'uri' is absent",
      "properties": {
        "bytes": {
          "description": "base64 encoded content of the file",
          "type": "string"
        },
        "mimeType": {
          "description": "Optional mimeType for the file",
          "type": "string"
        },
        "name": {
          "description": "Optional name for the file",
          "type": "string"
        }
      },
      "required": ["bytes"],
      "type": "object"
    },
    "FileWithUri": {
      "description": "Define the variant where 'uri' is present and 'bytes' is absent",
      "properties": {
        "mimeType": {
          "description": "Optional mimeType for the file",
          "type": "string"
        },
        "name": {
          "description": "Optional name for the file",
          "type": "string"
        },
        "uri": {
          "description": "URL for the File content",
          "type": "string"
        }
      },
      "required": ["uri"],
      "type": "object"
    },
    "GetTaskPushNotificationConfigRequest": {
      "description": "JSON-RPC request model for the 'tasks/pushNotificationConfig/get' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "method": {
          "const": "tasks/pushNotificationConfig/get",
          "description": "A String containing the name of the method to be invoked.",
          "type": "string"
        },
        "params": {
          "$ref": "#/definitions/TaskIdParams",
          "description": "A Structured value that holds the parameter values to be used during the invocation of the method."
        }
      },
      "required": ["jsonrpc", "method", "params"],
      "type": "object"
    },
    "GetTaskPushNotificationConfigResponse": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONRPCErrorResponse"
        },
        {
          "$ref": "#/definitions/GetTaskPushNotificationConfigSuccessResponse"
        }
      ],
      "description": "JSON-RPC response for the 'tasks/pushNotificationConfig/set' method."
    },
    "GetTaskPushNotificationConfigSuccessResponse": {
      "description": "JSON-RPC success response model for the 'tasks/pushNotificationConfig/get' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/TaskPushNotificationConfig",
          "description": "The result object on success."
        }
      },
      "required": ["jsonrpc", "result"],
      "type": "object"
    },
    "GetTaskRequest": {
      "description": "JSON-RPC request model for the 'tasks/get' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "method": {
          "const": "tasks/get",
          "description": "A String containing the name of the method to be invoked.",
          "type": "string"
        },
        "params": {
          "$ref": "#/definitions/TaskQueryParams",
          "description": "A Structured value that holds the parameter values to be used during the invocation of the method."
        }
      },
      "required": ["jsonrpc", "method", "params"],
      "type": "object"
    },
    "GetTaskResponse": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONRPCErrorResponse"
        },
        {
          "$ref": "#/definitions/GetTaskSuccessResponse"
        }
      ],
      "description": "JSON-RPC success response for the 'tasks/get' method."
    },
    "GetTaskSuccessResponse": {
      "description": "JSON-RPC success response for the 'tasks/get' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/Task",
          "description": "The result object on success."
        }
      },
      "required": ["jsonrpc", "result"],
      "type": "object"
    },
    "HTTPAuthSecurityScheme": {
      "description": "HTTP Authentication security scheme.",
      "properties": {
        "bearerFormat": {
          "description": "A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually\ngenerated by an authorization server, so this information is primarily for documentation\npurposes.",
          "type": "string"
        },
        "description": {
          "description": "Description of this security scheme.",
          "type": "string"
        },
        "scheme": {
          "description": "The name of the HTTP Authentication scheme to be used in the Authorization header as defined\nin RFC7235. The values used SHOULD be registered in the IANA Authentication Scheme registry.\nThe value is case-insensitive, as defined in RFC7235.",
          "type": "string"
        },
        "type": {
          "const": "http",
          "type": "string"
        }
      },
      "required": ["scheme", "type"],
      "type": "object"
    },
    "ImplicitOAuthFlow": {
      "description": "Configuration details for a supported OAuth Flow",
      "properties": {
        "authorizationUrl": {
          "description": "The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS",
          "type": "string"
        },
        "refreshUrl": {
          "description": "The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS.",
          "type": "string"
        },
        "scopes": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "The available scopes for the OAuth2 security scheme. A map between the scope name and a short\ndescription for it. The map MAY be empty.",
          "type": "object"
        }
      },
      "required": ["authorizationUrl", "scopes"],
      "type": "object"
    },
    "InternalError": {
      "description": "JSON-RPC error indicating an internal JSON-RPC error on the server.",
      "properties": {
        "code": {
          "const": -32603,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Internal error",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "InvalidAgentResponseError": {
      "description": "A2A specific error indicating agent returned invalid response for the current method",
      "properties": {
        "code": {
          "const": -32006,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Invalid agent response",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "InvalidParamsError": {
      "description": "JSON-RPC error indicating invalid method parameter(s).",
      "properties": {
        "code": {
          "const": -32602,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Invalid parameters",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "InvalidRequestError": {
      "description": "JSON-RPC error indicating the JSON sent is not a valid Request object.",
      "properties": {
        "code": {
          "const": -32600,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Request payload validation error",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "JSONParseError": {
      "description": "JSON-RPC error indicating invalid JSON was received by the server.",
      "properties": {
        "code": {
          "const": -32700,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Invalid JSON payload",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "JSONRPCError": {
      "description": "Represents a JSON-RPC 2.0 Error object.\nThis is typically included in a JSONRPCErrorResponse when an error occurs.",
      "properties": {
        "code": {
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "JSONRPCErrorResponse": {
      "description": "Represents a JSON-RPC 2.0 Error Response object.",
      "properties": {
        "error": {
          "anyOf": [
            {
              "$ref": "#/definitions/JSONRPCError"
            },
            {
              "$ref": "#/definitions/JSONParseError"
            },
            {
              "$ref": "#/definitions/InvalidRequestError"
            },
            {
              "$ref": "#/definitions/MethodNotFoundError"
            },
            {
              "$ref": "#/definitions/InvalidParamsError"
            },
            {
              "$ref": "#/definitions/InternalError"
            },
            {
              "$ref": "#/definitions/TaskNotFoundError"
            },
            {
              "$ref": "#/definitions/TaskNotCancelableError"
            },
            {
              "$ref": "#/definitions/PushNotificationNotSupportedError"
            },
            {
              "$ref": "#/definitions/UnsupportedOperationError"
            },
            {
              "$ref": "#/definitions/ContentTypeNotSupportedError"
            },
            {
              "$ref": "#/definitions/InvalidAgentResponseError"
            }
          ]
        },
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        }
      },
      "required": ["error", "jsonrpc"],
      "type": "object"
    },
    "JSONRPCMessage": {
      "description": "Base interface for any JSON-RPC 2.0 request or response.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        }
      },
      "required": ["jsonrpc"],
      "type": "object"
    },
    "JSONRPCRequest": {
      "description": "Represents a JSON-RPC 2.0 Request object.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "method": {
          "description": "A String containing the name of the method to be invoked.",
          "type": "string"
        },
        "params": {
          "additionalProperties": {},
          "description": "A Structured value that holds the parameter values to be used during the invocation of the method.",
          "type": "object"
        }
      },
      "required": ["jsonrpc", "method"],
      "type": "object"
    },
    "JSONRPCResponse": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONRPCErrorResponse"
        },
        {
          "$ref": "#/definitions/SendMessageSuccessResponse"
        },
        {
          "$ref": "#/definitions/SendStreamingMessageSuccessResponse"
        },
        {
          "$ref": "#/definitions/GetTaskSuccessResponse"
        },
        {
          "$ref": "#/definitions/CancelTaskSuccessResponse"
        },
        {
          "$ref": "#/definitions/SetTaskPushNotificationConfigSuccessResponse"
        },
        {
          "$ref": "#/definitions/GetTaskPushNotificationConfigSuccessResponse"
        }
      ],
      "description": "Represents a JSON-RPC 2.0 Response object."
    },
    "JSONRPCResult": {
      "description": "Represents a JSON-RPC 2.0 Result object.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "result": {
          "description": "The result object on success"
        }
      },
      "required": ["jsonrpc", "result"],
      "type": "object"
    },
    "Message": {
      "description": "Represents a single message exchanged between user and agent.",
      "properties": {
        "contextId": {
          "description": "The context the message is associated with",
          "type": "string"
        },
        "kind": {
          "const": "message",
          "description": "Event type",
          "type": "string"
        },
        "messageId": {
          "description": "Identifier created by the message creator",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Extension metadata.",
          "type": "object"
        },
        "parts": {
          "description": "Message content",
          "items": {
            "$ref": "#/definitions/Part"
          },
          "type": "array"
        },
        "referenceTaskIds": {
          "description": "List of tasks referenced as context by this message.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "role": {
          "description": "Message sender's role",
          "enum": ["agent", "user"],
          "type": "string"
        },
        "taskId": {
          "description": "Identifier of task the message is related to",
          "type": "string"
        }
      },
      "required": ["kind", "messageId", "parts", "role"],
      "type": "object"
    },
    "MessageSendConfiguration": {
      "description": "Configuration for the send message request.",
      "properties": {
        "acceptedOutputModes": {
          "description": "Accepted output modalities by the client.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "blocking": {
          "description": "If the server should treat the client as a blocking request.",
          "type": "boolean"
        },
        "historyLength": {
          "description": "Number of recent messages to be retrieved.",
          "type": "integer"
        },
        "pushNotificationConfig": {
          "$ref": "#/definitions/PushNotificationConfig",
          "description": "Where the server should send notifications when disconnected."
        }
      },
      "required": ["acceptedOutputModes"],
      "type": "object"
    },
    "MessageSendParams": {
      "description": "Sent by the client to the agent as a request. May create, continue or restart a task.",
      "properties": {
        "configuration": {
          "$ref": "#/definitions/MessageSendConfiguration",
          "description": "Send message configuration."
        },
        "message": {
          "$ref": "#/definitions/Message",
          "description": "The message being sent to the server."
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Extension metadata.",
          "type": "object"
        }
      },
      "required": ["message"],
      "type": "object"
    },
    "MethodNotFoundError": {
      "description": "JSON-RPC error indicating the method does not exist or is not available.",
      "properties": {
        "code": {
          "const": -32601,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Method not found",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "OAuth2SecurityScheme": {
      "description": "OAuth2.0 security scheme configuration.",
      "properties": {
        "description": {
          "description": "Description of this security scheme.",
          "type": "string"
        },
        "flows": {
          "$ref": "#/definitions/OAuthFlows",
          "description": "An object containing configuration information for the flow types supported."
        },
        "type": {
          "const": "oauth2",
          "type": "string"
        }
      },
      "required": ["flows", "type"],
      "type": "object"
    },
    "OAuthFlows": {
      "description": "Allows configuration of the supported OAuth Flows",
      "properties": {
        "authorizationCode": {
          "$ref": "#/definitions/AuthorizationCodeOAuthFlow",
          "description": "Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0."
        },
        "clientCredentials": {
          "$ref": "#/definitions/ClientCredentialsOAuthFlow",
          "description": "Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0"
        },
        "implicit": {
          "$ref": "#/definitions/ImplicitOAuthFlow",
          "description": "Configuration for the OAuth Implicit flow"
        },
        "password": {
          "$ref": "#/definitions/PasswordOAuthFlow",
          "description": "Configuration for the OAuth Resource Owner Password flow"
        }
      },
      "type": "object"
    },
    "OpenIdConnectSecurityScheme": {
      "description": "OpenID Connect security scheme configuration.",
      "properties": {
        "description": {
          "description": "Description of this security scheme.",
          "type": "string"
        },
        "openIdConnectUrl": {
          "description": "Well-known URL to discover the [[OpenID-Connect-Discovery]] provider metadata.",
          "type": "string"
        },
        "type": {
          "const": "openIdConnect",
          "type": "string"
        }
      },
      "required": ["openIdConnectUrl", "type"],
      "type": "object"
    },
    "Part": {
      "anyOf": [
        {
          "$ref": "#/definitions/TextPart"
        },
        {
          "$ref": "#/definitions/FilePart"
        },
        {
          "$ref": "#/definitions/DataPart"
        }
      ],
      "description": "Represents a part of a message, which can be text, a file, or structured data."
    },
    "PartBase": {
      "description": "Base properties common to all message parts.",
      "properties": {
        "metadata": {
          "additionalProperties": {},
          "description": "Optional metadata associated with the part.",
          "type": "object"
        }
      },
      "type": "object"
    },
    "PasswordOAuthFlow": {
      "description": "Configuration details for a supported OAuth Flow",
      "properties": {
        "refreshUrl": {
          "description": "The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2\nstandard requires the use of TLS.",
          "type": "string"
        },
        "scopes": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "The available scopes for the OAuth2 security scheme. A map between the scope name and a short\ndescription for it. The map MAY be empty.",
          "type": "object"
        },
        "tokenUrl": {
          "description": "The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard\nrequires the use of TLS.",
          "type": "string"
        }
      },
      "required": ["scopes", "tokenUrl"],
      "type": "object"
    },
    "PushNotificationAuthenticationInfo": {
      "description": "Defines authentication details for push notifications.",
      "properties": {
        "credentials": {
          "description": "Optional credentials",
          "type": "string"
        },
        "schemes": {
          "description": "Supported authentication schemes - e.g. Basic, Bearer",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": ["schemes"],
      "type": "object"
    },
    "PushNotificationConfig": {
      "description": "Configuration for setting up push notifications for task updates.",
      "properties": {
        "authentication": {
          "$ref": "#/definitions/PushNotificationAuthenticationInfo"
        },
        "token": {
          "description": "Token unique to this task/session.",
          "type": "string"
        },
        "url": {
          "description": "URL for sending the push notifications.",
          "type": "string"
        }
      },
      "required": ["url"],
      "type": "object"
    },
    "PushNotificationNotSupportedError": {
      "description": "A2A specific error indicating the agent does not support push notifications.",
      "properties": {
        "code": {
          "const": -32003,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Push Notification is not supported",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "SecurityScheme": {
      "anyOf": [
        {
          "$ref": "#/definitions/APIKeySecurityScheme"
        },
        {
          "$ref": "#/definitions/HTTPAuthSecurityScheme"
        },
        {
          "$ref": "#/definitions/OAuth2SecurityScheme"
        },
        {
          "$ref": "#/definitions/OpenIdConnectSecurityScheme"
        }
      ],
      "description": "Mirrors the OpenAPI Security Scheme Object\n(https://swagger.io/specification/#security-scheme-object)"
    },
    "SecuritySchemeBase": {
      "description": "Base properties shared by all security schemes.",
      "properties": {
        "description": {
          "description": "Description of this security scheme.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SendMessageRequest": {
      "description": "JSON-RPC request model for the 'message/send' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "method": {
          "const": "message/send",
          "description": "A String containing the name of the method to be invoked.",
          "type": "string"
        },
        "params": {
          "$ref": "#/definitions/MessageSendParams",
          "description": "A Structured value that holds the parameter values to be used during the invocation of the method."
        }
      },
      "required": ["jsonrpc", "method", "params"],
      "type": "object"
    },
    "SendMessageResponse": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONRPCErrorResponse"
        },
        {
          "$ref": "#/definitions/SendMessageSuccessResponse"
        }
      ],
      "description": "JSON-RPC response model for the 'message/send' method."
    },
    "SendMessageSuccessResponse": {
      "description": "JSON-RPC success response model for the 'message/send' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "result": {
          "anyOf": [
            {
              "$ref": "#/definitions/Task"
            },
            {
              "$ref": "#/definitions/Message"
            }
          ],
          "description": "The result object on success"
        }
      },
      "required": ["jsonrpc", "result"],
      "type": "object"
    },
    "SendStreamingMessageRequest": {
      "description": "JSON-RPC request model for the 'message/stream' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "method": {
          "const": "message/stream",
          "description": "A String containing the name of the method to be invoked.",
          "type": "string"
        },
        "params": {
          "$ref": "#/definitions/MessageSendParams",
          "description": "A Structured value that holds the parameter values to be used during the invocation of the method."
        }
      },
      "required": ["jsonrpc", "method", "params"],
      "type": "object"
    },
    "SendStreamingMessageResponse": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONRPCErrorResponse"
        },
        {
          "$ref": "#/definitions/SendStreamingMessageSuccessResponse"
        }
      ],
      "description": "JSON-RPC response model for the 'message/stream' method."
    },
    "SendStreamingMessageSuccessResponse": {
      "description": "JSON-RPC success response model for the 'message/stream' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "result": {
          "anyOf": [
            {
              "$ref": "#/definitions/Task"
            },
            {
              "$ref": "#/definitions/Message"
            },
            {
              "$ref": "#/definitions/TaskStatusUpdateEvent"
            },
            {
              "$ref": "#/definitions/TaskArtifactUpdateEvent"
            }
          ],
          "description": "The result object on success"
        }
      },
      "required": ["jsonrpc", "result"],
      "type": "object"
    },
    "SetTaskPushNotificationConfigRequest": {
      "description": "JSON-RPC request model for the 'tasks/pushNotificationConfig/set' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "method": {
          "const": "tasks/pushNotificationConfig/set",
          "description": "A String containing the name of the method to be invoked.",
          "type": "string"
        },
        "params": {
          "$ref": "#/definitions/TaskPushNotificationConfig",
          "description": "A Structured value that holds the parameter values to be used during the invocation of the method."
        }
      },
      "required": ["jsonrpc", "method", "params"],
      "type": "object"
    },
    "SetTaskPushNotificationConfigResponse": {
      "anyOf": [
        {
          "$ref": "#/definitions/JSONRPCErrorResponse"
        },
        {
          "$ref": "#/definitions/SetTaskPushNotificationConfigSuccessResponse"
        }
      ],
      "description": "JSON-RPC response for the 'tasks/pushNotificationConfig/set' method."
    },
    "SetTaskPushNotificationConfigSuccessResponse": {
      "description": "JSON-RPC success response model for the 'tasks/pushNotificationConfig/set' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/TaskPushNotificationConfig",
          "description": "The result object on success."
        }
      },
      "required": ["jsonrpc", "result"],
      "type": "object"
    },
    "Task": {
      "properties": {
        "artifacts": {
          "description": "Collection of artifacts created by the agent.",
          "items": {
            "$ref": "#/definitions/Artifact"
          },
          "type": "array"
        },
        "contextId": {
          "description": "Server-generated id for contextual alignment across interactions",
          "type": "string"
        },
        "history": {
          "items": {
            "$ref": "#/definitions/Message"
          },
          "type": "array"
        },
        "id": {
          "description": "Unique identifier for the task",
          "type": "string"
        },
        "kind": {
          "const": "task",
          "description": "Event type",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Extension metadata.",
          "type": "object"
        },
        "status": {
          "$ref": "#/definitions/TaskStatus",
          "description": "Current status of the task"
        }
      },
      "required": ["contextId", "id", "kind", "status"],
      "type": "object"
    },
    "TaskArtifactUpdateEvent": {
      "description": "Sent by server during sendStream or subscribe requests",
      "properties": {
        "append": {
          "description": "Indicates if this artifact appends to a previous one",
          "type": "boolean"
        },
        "artifact": {
          "$ref": "#/definitions/Artifact",
          "description": "Generated artifact"
        },
        "contextId": {
          "description": "The context the task is associated with",
          "type": "string"
        },
        "kind": {
          "const": "artifact-update",
          "description": "Event type",
          "type": "string"
        },
        "lastChunk": {
          "description": "Indicates if this is the last chunk of the artifact",
          "type": "boolean"
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Extension metadata.",
          "type": "object"
        },
        "taskId": {
          "description": "Task id",
          "type": "string"
        }
      },
      "required": ["artifact", "contextId", "kind", "taskId"],
      "type": "object"
    },
    "TaskIdParams": {
      "description": "Parameters containing only a task ID, used for simple task operations.",
      "properties": {
        "id": {
          "description": "Task id.",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "type": "object"
        }
      },
      "required": ["id"],
      "type": "object"
    },
    "TaskNotCancelableError": {
      "description": "A2A specific error indicating the task is in a state where it cannot be canceled.",
      "properties": {
        "code": {
          "const": -32002,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Task cannot be canceled",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "TaskNotFoundError": {
      "description": "A2A specific error indicating the requested task ID was not found.",
      "properties": {
        "code": {
          "const": -32001,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "Task not found",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    },
    "TaskPushNotificationConfig": {
      "description": "Parameters for setting or getting push notification configuration for a task",
      "properties": {
        "pushNotificationConfig": {
          "$ref": "#/definitions/PushNotificationConfig",
          "description": "Push notification configuration."
        },
        "taskId": {
          "description": "Task id.",
          "type": "string"
        }
      },
      "required": ["pushNotificationConfig", "taskId"],
      "type": "object"
    },
    "TaskQueryParams": {
      "description": "Parameters for querying a task, including optional history length.",
      "properties": {
        "historyLength": {
          "description": "Number of recent messages to be retrieved.",
          "type": "integer"
        },
        "id": {
          "description": "Task id.",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "type": "object"
        }
      },
      "required": ["id"],
      "type": "object"
    },
    "TaskResubscriptionRequest": {
      "description": "JSON-RPC request model for the 'tasks/resubscribe' method.",
      "properties": {
        "id": {
          "description": "An identifier established by the Client that MUST contain a String, Number.\nNumbers SHOULD NOT contain fractional parts.",
          "type": ["string", "integer"]
        },
        "jsonrpc": {
          "const": "2.0",
          "description": "Specifies the version of the JSON-RPC protocol. MUST be exactly \"2.0\".",
          "type": "string"
        },
        "method": {
          "const": "tasks/resubscribe",
          "description": "A String containing the name of the method to be invoked.",
          "type": "string"
        },
        "params": {
          "$ref": "#/definitions/TaskIdParams",
          "description": "A Structured value that holds the parameter values to be used during the invocation of the method."
        }
      },
      "required": ["jsonrpc", "method", "params"],
      "type": "object"
    },
    "TaskState": {
      "description": "Represents the possible states of a Task.",
      "enum": [
        "submitted",
        "working",
        "input-required",
        "completed",
        "canceled",
        "failed",
        "rejected",
        "auth-required",
        "unknown"
      ],
      "type": "string"
    },
    "TaskStatus": {
      "description": "TaskState and accompanying message.",
      "properties": {
        "message": {
          "$ref": "#/definitions/Message",
          "description": "Additional status updates for client"
        },
        "state": {
          "$ref": "#/definitions/TaskState"
        },
        "timestamp": {
          "description": "ISO 8601 datetime string when the status was recorded.",
          "type": "string"
        }
      },
      "required": ["state"],
      "type": "object"
    },
    "TaskStatusUpdateEvent": {
      "description": "Sent by server during sendStream or subscribe requests",
      "properties": {
        "contextId": {
          "description": "The context the task is associated with",
          "type": "string"
        },
        "final": {
          "description": "Indicates the end of the event stream",
          "type": "boolean"
        },
        "kind": {
          "const": "status-update",
          "description": "Event type",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Extension metadata.",
          "type": "object"
        },
        "status": {
          "$ref": "#/definitions/TaskStatus",
          "description": "Current status of the task"
        },
        "taskId": {
          "description": "Task id",
          "type": "string"
        }
      },
      "required": ["contextId", "final", "kind", "status", "taskId"],
      "type": "object"
    },
    "TextPart": {
      "description": "Represents a text segment within parts.",
      "properties": {
        "kind": {
          "const": "text",
          "description": "Part type - text for TextParts",
          "type": "string"
        },
        "metadata": {
          "additionalProperties": {},
          "description": "Optional metadata associated with the part.",
          "type": "object"
        },
        "text": {
          "description": "Text content",
          "type": "string"
        }
      },
      "required": ["kind", "text"],
      "type": "object"
    },
    "UnsupportedOperationError": {
      "description": "A2A specific error indicating the requested operation is not supported by the agent.",
      "properties": {
        "code": {
          "const": -32004,
          "description": "A Number that indicates the error type that occurred.",
          "type": "integer"
        },
        "data": {
          "description": "A Primitive or Structured value that contains additional information about the error.\nThis may be omitted."
        },
        "message": {
          "default": "This operation is not supported",
          "description": "A String providing a short description of the error.",
          "type": "string"
        }
      },
      "required": ["code", "message"],
      "type": "object"
    }
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/types/types.ts`:

```ts
import { z } from "zod/v4";

// --- ENUMS ---
/**
 * Represents the possible states of a Task.
 */
export const TaskStateEnum = z.enum([
  "submitted",
  "working",
  "input-required",
  "completed",
  "canceled",
  "failed",
  "rejected",
  "auth-required",
  "unknown",
]);
export type TaskState = z.infer<typeof TaskStateEnum>;

/**
 * Message sender's role: "agent" or "user".
 */
export const MessageRoleEnum = z.enum(["agent", "user"]);
export type MessageRole = z.infer<typeof MessageRoleEnum>;

// --- BASES & COMMONS ---
/**
 * Base properties common to all message parts.
 */
export const PartBaseSchema = z.object({
  /**
   * Optional metadata associated with the part.
   */
  metadata: z.record(z.string(), z.any()).optional(),
});

// --- PARTS ---
/**
 * Represents a text segment within parts.
 */
export const TextPartSchema = z.object({
  /**
   * Part type - text for TextParts
   */
  kind: z.literal("text"),
  /**
   * Text content
   */
  text: z.string(),
  /**
   * Optional metadata associated with the part.
   */
  metadata: z.record(z.string(), z.any()).optional(),
});
export type TextPart = z.infer<typeof TextPartSchema>;

/**
 * Define the variant where 'bytes' is present and 'uri' is absent.
 */
export const FileWithBytesSchema = z.object({
  /**
   * base64 encoded content of the file
   */
  bytes: z.string(),
  /**
   * Optional mimeType for the file
   */
  mimeType: z.string().optional(),
  /**
   * Optional name for the file
   */
  name: z.string().optional(),
});
export type FileWithBytes = z.infer<typeof FileWithBytesSchema>;

/**
 * Define the variant where 'uri' is present and 'bytes' is absent.
 */
export const FileWithUriSchema = z.object({
  /**
   * URL for the File content
   */
  uri: z.string(),
  /**
   * Optional mimeType for the file
   */
  mimeType: z.string().optional(),
  /**
   * Optional name for the file
   */
  name: z.string().optional(),
});
export type FileWithUri = z.infer<typeof FileWithUriSchema>;

/**
 * Represents a File segment within parts.
 */
export const FilePartSchema = z.object({
  /**
   * Part type - file for FileParts
   */
  kind: z.literal("file"),
  /**
   * File content either as url or bytes
   */
  file: z.union([FileWithBytesSchema, FileWithUriSchema]),
  /**
   * Optional metadata associated with the part.
   */
  metadata: z.record(z.string(), z.any()).optional(),
});
export type FilePart = z.infer<typeof FilePartSchema>;

/**
 * Represents a structured data segment within a message part.
 */
export const DataPartSchema = z.object({
  /**
   * Part type - data for DataParts
   */
  kind: z.literal("data"),
  /**
   * Structured data content
   */
  data: z.record(z.string(), z.any()),
  /**
   * Optional metadata associated with the part.
   */
  metadata: z.record(z.string(), z.any()).optional(),
});
export type DataPart = z.infer<typeof DataPartSchema>;

/**
 * Represents a part of a message, which can be text, a file, or structured data.
 */
export const PartSchema = z.union([
  TextPartSchema,
  FilePartSchema,
  DataPartSchema,
]);
export type Part = z.infer<typeof PartSchema>;

// --- MESSAGE ---
/**
 * Represents a single message exchanged between user and agent.
 */
export const MessageSchema = z.object({
  /**
   * Event type
   */
  kind: z.literal("message"),
  /**
   * Identifier created by the message creator
   */
  messageId: z.string(),
  /**
   * Message content
   */
  parts: z.array(PartSchema),
  /**
   * Message sender's role
   */
  role: MessageRoleEnum,
  /**
   * The context the message is associated with
   */
  contextId: z.string().optional(),
  /**
   * Extension metadata.
   */
  metadata: z.record(z.string(), z.any()).optional(),
  /**
   * List of tasks referenced as context by this message.
   */
  referenceTaskIds: z.array(z.string()).optional(),
  /**
   * Identifier of task the message is related to
   */
  taskId: z.string().optional(),
});
export type Message = z.infer<typeof MessageSchema>;

// --- ARTIFACT ---
/**
 * Represents an artifact generated for a task.
 */
export const ArtifactSchema = z.object({
  /**
   * Unique identifier for the artifact.
   */
  artifactId: z.string(),
  /**
   * Optional description for the artifact.
   */
  description: z.string().optional(),
  /**
   * Extension metadata.
   */
  metadata: z.record(z.string(), z.any()).optional(),
  /**
   * Optional name for the artifact.
   */
  name: z.string().optional(),
  /**
   * Artifact parts.
   */
  parts: z.array(PartSchema),
});
export type Artifact = z.infer<typeof ArtifactSchema>;

// --- AGENT ---
/**
 * Defines optional capabilities supported by an agent.
 */
export const AgentCapabilitiesSchema = z.object({
  /**
   * true if the agent can notify updates to client.
   */
  pushNotifications: z.boolean().optional(),
  /**
   * true if the agent exposes status change history for tasks.
   */
  stateTransitionHistory: z.boolean().optional(),
  /**
   * true if the agent supports SSE.
   */
  streaming: z.boolean().optional(),
});
export type AgentCapabilities = z.infer<typeof AgentCapabilitiesSchema>;

/**
 * Represents the service provider of an agent.
 */
export const AgentProviderSchema = z.object({
  /**
   * Agent provider's organization name.
   */
  organization: z.string(),
  /**
   * Agent provider's URL.
   */
  url: z.string(),
});
export type AgentProvider = z.infer<typeof AgentProviderSchema>;

/**
 * Represents a unit of capability that an agent can perform.
 */
export const AgentSkillSchema = z.object({
  /**
   * Description of the skill - will be used by the client or a human as a hint to understand what the skill does.
   */
  description: z.string(),
  /**
   * The set of example scenarios that the skill can perform.
   */
  examples: z.array(z.string()).optional(),
  /**
   * Unique identifier for the agent's skill.
   */
  id: z.string(),
  /**
   * The set of interaction modes that the skill supports (if different than the default). Supported mime types for input.
   */
  inputModes: z.array(z.string()).optional(),
  /**
   * Human readable name of the skill.
   */
  name: z.string(),
  /**
   * Supported mime types for output.
   */
  outputModes: z.array(z.string()).optional(),
  /**
   * Set of tags describing classes of capabilities for this specific skill.
   */
  tags: z.array(z.string()),
});
export type AgentSkill = z.infer<typeof AgentSkillSchema>;

/**
 * An AgentCard conveys key information:
 * - Overall details (version, name, description, uses)
 * - Skills: A set of capabilities the agent can perform
 * - Default modalities/content types supported by the agent.
 * - Authentication requirements
 */
export const AgentCardSchema = z.object({
  /**
   * Optional capabilities supported by the agent.
   */
  capabilities: AgentCapabilitiesSchema.optional(),
  /**
   * The set of interaction modes that the agent supports across all skills. This can be overridden per-skill. Supported mime types for input.
   */
  defaultInputModes: z.array(z.string()),
  /**
   * Supported mime types for output.
   */
  defaultOutputModes: z.array(z.string()),
  /**
   * A human-readable description of the agent. Used to assist users and other agents in understanding what the agent can do.
   */
  description: z.string(),
  /**
   * A URL to documentation for the agent.
   */
  documentationUrl: z.string().optional(),
  /**
   * Human readable name of the agent.
   */
  name: z.string(),
  /**
   * The service provider of the agent
   */
  provider: AgentProviderSchema.optional(),
  /**
   * Security requirements for contacting the agent.
   */
  security: z.array(z.object({}).catchall(z.array(z.string()))).optional(),
  /**
   * Security scheme details used for authenticating with this agent.
   */
  securitySchemes: z.record(z.string(), z.any()).optional(), // SecurityScheme is a union, see below
  /**
   * Skills are a unit of capability that an agent can perform.
   */
  skills: z.array(AgentSkillSchema),
  /**
   * true if the agent supports providing an extended agent card when the user is authenticated. Defaults to false if not specified.
   */
  supportsAuthenticatedExtendedCard: z.boolean().optional(),
  /**
   * A URL to the address the agent is hosted at.
   */
  url: z.string(),
  /**
   * The version of the agent - format is up to the provider.
   */
  version: z.string(),
});
export type AgentCard = z.infer<typeof AgentCardSchema>;

// --- SECURITY SCHEMES ---
/**
 * Defines an API key security scheme.
 */
export const APIKeySecuritySchemeSchema = z.object({
  /**
   * A description for the security scheme.
   */
  description: z.string().optional(),
  /**
   * The location of the API key.
   */
  in: z.enum(["cookie", "header", "query"]),
  /**
   * The name of the header, query, or cookie parameter to be used.
   */
  name: z.string(),
  /**
   * The type of the security scheme (apiKey).
   */
  type: z.literal("apiKey"),
});
export type APIKeySecurityScheme = z.infer<typeof APIKeySecuritySchemeSchema>;

/**
 * Defines an HTTP authentication security scheme.
 */
export const HTTPAuthSecuritySchemeSchema = z.object({
  /**
   * A hint to the client to identify how the bearer token is formatted.
   */
  bearerFormat: z.string().optional(),
  /**
   * A description for the security scheme.
   */
  description: z.string().optional(),
  /**
   * The name of the HTTP Authorization scheme to be used in the Authorization header.
   */
  scheme: z.string(),
  /**
   * The type of the security scheme (http).
   */
  type: z.literal("http"),
});
export type HTTPAuthSecurityScheme = z.infer<
  typeof HTTPAuthSecuritySchemeSchema
>;

/**
 * Configuration for OAuth2 authorization code flow.
 */
export const AuthorizationCodeOAuthFlowSchema = z.object({
  /**
   * The authorization URL to be used for this flow.
   */
  authorizationUrl: z.string(),
  /**
   * The refresh URL to be used for obtaining refresh tokens.
   */
  refreshUrl: z.string().optional(),
  /**
   * The available scopes for the OAuth2 security scheme.
   */
  scopes: z.record(z.string(), z.string()),
  /**
   * The token URL to be used for this flow.
   */
  tokenUrl: z.string(),
});
export type AuthorizationCodeOAuthFlow = z.infer<
  typeof AuthorizationCodeOAuthFlowSchema
>;

/**
 * Configuration for OAuth2 client credentials flow.
 */
export const ClientCredentialsOAuthFlowSchema = z.object({
  /**
   * The refresh URL to be used for obtaining refresh tokens.
   */
  refreshUrl: z.string().optional(),
  /**
   * The available scopes for the OAuth2 security scheme.
   */
  scopes: z.record(z.string(), z.string()),
  /**
   * The token URL to be used for this flow.
   */
  tokenUrl: z.string(),
});
export type ClientCredentialsOAuthFlow = z.infer<
  typeof ClientCredentialsOAuthFlowSchema
>;

/**
 * Configuration for OAuth2 implicit flow.
 */
export const ImplicitOAuthFlowSchema = z.object({
  /**
   * The authorization URL to be used for this flow.
   */
  authorizationUrl: z.string(),
  /**
   * The refresh URL to be used for obtaining refresh tokens.
   */
  refreshUrl: z.string().optional(),
  /**
   * The available scopes for the OAuth2 security scheme.
   */
  scopes: z.record(z.string(), z.string()),
});
export type ImplicitOAuthFlow = z.infer<typeof ImplicitOAuthFlowSchema>;

/**
 * Configuration for OAuth2 password flow.
 */
export const PasswordOAuthFlowSchema = z.object({
  /**
   * The refresh URL to be used for obtaining refresh tokens.
   */
  refreshUrl: z.string().optional(),
  /**
   * The available scopes for the OAuth2 security scheme.
   */
  scopes: z.record(z.string(), z.string()),
  /**
   * The token URL to be used for this flow.
   */
  tokenUrl: z.string(),
});
export type PasswordOAuthFlow = z.infer<typeof PasswordOAuthFlowSchema>;

/**
 * Lists supported OAuth2 flows for a security scheme.
 */
export const OAuthFlowsSchema = z.object({
  /**
   * Configuration for OAuth2 authorization code flow.
   */
  authorizationCode: AuthorizationCodeOAuthFlowSchema.optional(),
  /**
   * Configuration for OAuth2 client credentials flow.
   */
  clientCredentials: ClientCredentialsOAuthFlowSchema.optional(),
  /**
   * Configuration for OAuth2 implicit flow.
   */
  implicit: ImplicitOAuthFlowSchema.optional(),
  /**
   * Configuration for OAuth2 password flow.
   */
  password: PasswordOAuthFlowSchema.optional(),
});
export type OAuthFlows = z.infer<typeof OAuthFlowsSchema>;

/**
 * Defines an OAuth2 security scheme.
 */
export const OAuth2SecuritySchemeSchema = z.object({
  /**
   * A description for the security scheme.
   */
  description: z.string().optional(),
  /**
   * Lists supported OAuth2 flows.
   */
  flows: OAuthFlowsSchema,
  /**
   * The type of the security scheme (oauth2).
   */
  type: z.literal("oauth2"),
});
export type OAuth2SecurityScheme = z.infer<typeof OAuth2SecuritySchemeSchema>;

/**
 * Defines an OpenID Connect security scheme.
 */
export const OpenIdConnectSecuritySchemeSchema = z.object({
  /**
   * A description for the security scheme.
   */
  description: z.string().optional(),
  /**
   * OpenId Connect URL to discover OAuth2 endpoints.
   */
  openIdConnectUrl: z.string(),
  /**
   * The type of the security scheme (openIdConnect).
   */
  type: z.literal("openIdConnect"),
});
export type OpenIdConnectSecurityScheme = z.infer<
  typeof OpenIdConnectSecuritySchemeSchema
>;

/**
 * Union type for supported security schemes.
 */
export const SecuritySchemeSchema = z.union([
  APIKeySecuritySchemeSchema,
  HTTPAuthSecuritySchemeSchema,
  OAuth2SecuritySchemeSchema,
  OpenIdConnectSecuritySchemeSchema,
]);
export type SecurityScheme = z.infer<typeof SecuritySchemeSchema>;

// --- PUSH NOTIFICATIONS ---
/**
 * Authentication information for push notifications.
 */
export const PushNotificationAuthenticationInfoSchema = z.object({
  /**
   * Optional credentials for push notification authentication.
   */
  credentials: z.string().optional(),
  /**
   * Array of supported authentication schemes.
   */
  schemes: z.array(z.string()),
});
export type PushNotificationAuthenticationInfo = z.infer<
  typeof PushNotificationAuthenticationInfoSchema
>;

/**
 * Configuration for push notifications for a task.
 */
export const PushNotificationConfigSchema = z.object({
  /**
   * Optional authentication information for push notifications.
   */
  authentication: PushNotificationAuthenticationInfoSchema.optional(),
  /**
   * Optional push notification token.
   */
  token: z.string().optional(),
  /**
   * URL to send push notifications to.
   */
  url: z.string(),
});
export type PushNotificationConfig = z.infer<
  typeof PushNotificationConfigSchema
>;

/**
 * Associates a push notification config with a task.
 */
export const TaskPushNotificationConfigSchema = z.object({
  /**
   * Push notification configuration.
   */
  pushNotificationConfig: PushNotificationConfigSchema,
  /**
   * ID of the task.
   */
  taskId: z.string(),
});
export type TaskPushNotificationConfig = z.infer<
  typeof TaskPushNotificationConfigSchema
>;

// --- TASKS ---
/**
 * Represents the status of a task.
 */
export const TaskStatusSchema = z.object({
  /**
   * Most recent message for the task.
   */
  message: MessageSchema.optional(),
  /**
   * Current state of the task.
   */
  state: TaskStateEnum,
  /**
   * ISO 8601 datetime string when the status was recorded.
   */
  timestamp: z.string().optional(),
});
export type TaskStatus = z.infer<typeof TaskStatusSchema>;

/**
 * Represents a task in the system.
 */
export const TaskSchema = z.object({
  /**
   * Artifacts generated for the task.
   */
  artifacts: z.array(ArtifactSchema).optional(),
  /**
   * Context ID associated with the task.
   */
  contextId: z.string(),
  /**
   * History of messages for the task.
   */
  history: z.array(MessageSchema).optional(),
  /**
   * Unique identifier for the task.
   */
  id: z.string(),
  /**
   * Type of object (always "task").
   */
  kind: z.literal("task"),
  /**
   * Extension metadata.
   */
  metadata: z.record(z.string(), z.any()).optional(),
  /**
   * Current status of the task.
   */
  status: TaskStatusSchema,
});
export type Task = z.infer<typeof TaskSchema>;

// --- EVENTS ---
/**
 * Event indicating a status update for a task.
 */
export const TaskStatusUpdateEventSchema = z.object({
  /**
   * Context ID associated with the event.
   */
  contextId: z.string(),
  /**
   * Whether this is the final status update for the task.
   */
  final: z.boolean(),
  /**
   * Event type (always "status-update").
   */
  kind: z.literal("status-update"),
  /**
   * Extension metadata.
   */
  metadata: z.record(z.string(), z.any()).optional(),
  /**
   * Status of the task after the update.
   */
  status: TaskStatusSchema,
  /**
   * ID of the task.
   */
  taskId: z.string(),
});
export type TaskStatusUpdateEvent = z.infer<typeof TaskStatusUpdateEventSchema>;

/**
 * Event indicating an artifact update for a task.
 */
export const TaskArtifactUpdateEventSchema = z.object({
  /**
   * If true, the artifact is appended to the task's artifacts array.
   */
  append: z.boolean().optional(),
  /**
   * The artifact that was updated.
   */
  artifact: ArtifactSchema,
  /**
   * Context ID associated with the event.
   */
  contextId: z.string(),
  /**
   * Event type (always "artifact-update").
   */
  kind: z.literal("artifact-update"),
  /**
   * If true, this is the last chunk of the artifact.
   */
  lastChunk: z.boolean().optional(),
  /**
   * Extension metadata.
   */
  metadata: z.record(z.string(), z.any()).optional(),
  /**
   * ID of the task.
   */
  taskId: z.string(),
});
export type TaskArtifactUpdateEvent = z.infer<
  typeof TaskArtifactUpdateEventSchema
>;

// --- PARAMS ---
/**
 * Parameters for identifying a task by ID.
 */
export const TaskIdParamsSchema = z.object({
  /**
   * The ID of the task.
   */
  id: z.string(),
  /**
   * Optional metadata for the operation.
   */
  metadata: z.record(z.string(), z.any()).optional(),
});
export type TaskIdParams = z.infer<typeof TaskIdParamsSchema>;

/**
 * Parameters for querying a task, including optional history length.
 */
export const TaskQueryParamsSchema = z.object({
  /**
   * Number of messages to include in the returned history.
   */
  historyLength: z.number().optional(),
  /**
   * The ID of the task.
   */
  id: z.string(),
  /**
   * Optional metadata for the operation.
   */
  metadata: z.record(z.string(), z.any()).optional(),
});
export type TaskQueryParams = z.infer<typeof TaskQueryParamsSchema>;

// --- MESSAGE SEND ---
/**
 * Configuration options for sending a message.
 */
export const MessageSendConfigurationSchema = z.object({
  /**
   * List of accepted output modes (MIME types).
   */
  acceptedOutputModes: z.array(z.string()),
  /**
   * If true, the request is blocking.
   */
  blocking: z.boolean().optional(),
  /**
   * Number of messages to include in the returned history.
   */
  historyLength: z.number().optional(),
  /**
   * Optional push notification config for the message.
   */
  pushNotificationConfig: PushNotificationConfigSchema.optional(),
});
export type MessageSendConfiguration = z.infer<
  typeof MessageSendConfigurationSchema
>;

/**
 * Parameters for sending a message.
 */
export const MessageSendParamsSchema = z.object({
  /**
   * Optional configuration for sending the message.
   */
  configuration: MessageSendConfigurationSchema.optional(),
  /**
   * The message to send.
   */
  message: MessageSchema,
  /**
   * Optional metadata for the operation.
   */
  metadata: z.record(z.string(), z.any()).optional(),
});
export type MessageSendParams = z.infer<typeof MessageSendParamsSchema>;

// --- ERROR TYPES ---
/**
 * Helper for constructing error schemas with code and default message.
 */
function errorType(constant: number, defaultMsg: string) {
  return z.object({
    /**
     * A Number that indicates the error type that occurred.
     */
    code: z.literal(constant),
    /**
     * A Primitive or Structured value that contains additional information about the error.
     * This may be omitted.
     */
    data: z.any().optional(),
    /**
     * A String providing a short description of the error.
     */
    message: z.string().default(defaultMsg),
  });
}

export enum ErrorType {
  JSONParseError = -32700,
  InvalidRequestError = -32600,
  MethodNotFoundError = -32601,
  InvalidParamsError = -32602,
  InternalError = -32603,
  TaskNotFoundError = -32001,
  TaskNotCancelableError = -32002,
  PushNotificationNotSupportedError = -32003,
  UnsupportedOperationError = -32004,
  ContentTypeNotSupportedError = -32005,
  InvalidAgentResponseError = -32006,
}

export const JSONParseErrorSchema = errorType(
  ErrorType.JSONParseError,
  "Invalid JSON payload"
);
export type JSONParseError = z.infer<typeof JSONParseErrorSchema>;

export const InvalidRequestErrorSchema = errorType(
  ErrorType.InvalidRequestError,
  "Request payload validation error"
);
export type InvalidRequestError = z.infer<typeof InvalidRequestErrorSchema>;

export const MethodNotFoundErrorSchema = errorType(
  ErrorType.MethodNotFoundError,
  "Method not found"
);
export type MethodNotFoundError = z.infer<typeof MethodNotFoundErrorSchema>;

export const InvalidParamsErrorSchema = errorType(
  ErrorType.InvalidParamsError,
  "Invalid parameters"
);
export type InvalidParamsError = z.infer<typeof InvalidParamsErrorSchema>;

export const InternalErrorSchema = errorType(
  ErrorType.InternalError,
  "Internal error"
);
export type InternalError = z.infer<typeof InternalErrorSchema>;

export const TaskNotFoundErrorSchema = errorType(
  ErrorType.TaskNotFoundError,
  "Task not found"
);
export type TaskNotFoundError = z.infer<typeof TaskNotFoundErrorSchema>;

export const TaskNotCancelableErrorSchema = errorType(
  ErrorType.TaskNotCancelableError,
  "Task cannot be canceled"
);
export type TaskNotCancelableError = z.infer<
  typeof TaskNotCancelableErrorSchema
>;

export const PushNotificationNotSupportedErrorSchema = errorType(
  ErrorType.PushNotificationNotSupportedError,
  "Push Notification is not supported"
);
export type PushNotificationNotSupportedError = z.infer<
  typeof PushNotificationNotSupportedErrorSchema
>;

export const UnsupportedOperationErrorSchema = errorType(
  ErrorType.UnsupportedOperationError,
  "This operation is not supported"
);
export type UnsupportedOperationError = z.infer<
  typeof UnsupportedOperationErrorSchema
>;

export const ContentTypeNotSupportedErrorSchema = errorType(
  ErrorType.ContentTypeNotSupportedError,
  "Incompatible content types"
);
export type ContentTypeNotSupportedError = z.infer<
  typeof ContentTypeNotSupportedErrorSchema
>;

export const InvalidAgentResponseErrorSchema = errorType(
  ErrorType.InvalidAgentResponseError,
  "Invalid agent response"
);
export type InvalidAgentResponseError = z.infer<
  typeof InvalidAgentResponseErrorSchema
>;

// --- JSON-RPC ---
/**
 * Generic JSON-RPC error schema.
 */
export const JSONRPCErrorSchema = z.object({
  /**
   * Error code.
   */
  code: z.number(),
  /**
   * Optional error data.
   */
  data: z.any().optional(),
  /**
   * Error message.
   */
  message: z.string(),
});
export type JSONRPCError = z.infer<typeof JSONRPCErrorSchema>;
export const isJSONRPCError = (value: unknown): value is JSONRPCError =>
  JSONRPCErrorSchema.safeParse(value).success;

/**
 * JSON-RPC error response.
 */
export const JSONRPCErrorResponseSchema = z.object({
  /**
   * The error object.
   */
  error: z.union([
    JSONRPCErrorSchema,
    JSONParseErrorSchema,
    InvalidRequestErrorSchema,
    MethodNotFoundErrorSchema,
    InvalidParamsErrorSchema,
    InternalErrorSchema,
    TaskNotFoundErrorSchema,
    TaskNotCancelableErrorSchema,
    PushNotificationNotSupportedErrorSchema,
    UnsupportedOperationErrorSchema,
    ContentTypeNotSupportedErrorSchema,
    InvalidAgentResponseErrorSchema,
  ]),
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
});
export type JSONRPCErrorResponse = z.infer<typeof JSONRPCErrorResponseSchema>;

/**
 * Base JSON-RPC message schema.
 */
export const JSONRPCMessageSchema = z.object({
  /**
   * The ID of the request or response.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
});
export type JSONRPCMessage = z.infer<typeof JSONRPCMessageSchema>;

/**
 * JSON-RPC request schema.
 */
export const JSONRPCRequestSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The method to invoke.
   */
  method: z.string(),
  /**
   * Optional parameters for the method.
   */
  params: z.record(z.string(), z.any()).optional(),
});
export type JSONRPCRequest = z.infer<typeof JSONRPCRequestSchema>;

/**
 * JSON-RPC result schema.
 */
export const JSONRPCResultSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The result of the request.
   */
  result: z.any(),
});
export type JSONRPCResult = z.infer<typeof JSONRPCResultSchema>;

/**
 * JSON-RPC response schema.
 */
export const JSONRPCResponseSchema = z.union([
  JSONRPCResultSchema,
  JSONRPCErrorResponseSchema,
]);
export type JSONRPCResponse = z.infer<typeof JSONRPCResponseSchema>;

// --- REQUESTS ---
/**
 * JSON-RPC request for sending a message.
 */
export const SendMessageRequestSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The method (always "message/send").
   */
  method: z.literal("message/send"),
  /**
   * Parameters for sending the message.
   */
  params: MessageSendParamsSchema,
});
export type SendMessageRequest = z.infer<typeof SendMessageRequestSchema>;

/**
 * JSON-RPC request for streaming a message.
 */
export const SendStreamingMessageRequestSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The method (always "message/stream").
   */
  method: z.literal("message/stream"),
  /**
   * Parameters for streaming the message.
   */
  params: MessageSendParamsSchema,
});
export type SendStreamingMessageRequest = z.infer<
  typeof SendStreamingMessageRequestSchema
>;

/**
 * JSON-RPC request for retrieving a task.
 */
export const GetTaskRequestSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The method (always "tasks/get").
   */
  method: z.literal("tasks/get"),
  /**
   * Parameters for querying the task.
   */
  params: TaskQueryParamsSchema,
});
export type GetTaskRequest = z.infer<typeof GetTaskRequestSchema>;

/**
 * JSON-RPC request for canceling a task.
 */
export const CancelTaskRequestSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The method (always "tasks/cancel").
   */
  method: z.literal("tasks/cancel"),
  /**
   * Parameters for canceling the task.
   */
  params: TaskIdParamsSchema,
});
export type CancelTaskRequest = z.infer<typeof CancelTaskRequestSchema>;

/**
 * JSON-RPC request for setting push notification config for a task.
 */
export const SetTaskPushNotificationConfigRequestSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The method (always "tasks/pushNotificationConfig/set").
   */
  method: z.literal("tasks/pushNotificationConfig/set"),
  /**
   * Parameters for setting push notification config.
   */
  params: TaskPushNotificationConfigSchema,
});
export type SetTaskPushNotificationConfigRequest = z.infer<
  typeof SetTaskPushNotificationConfigRequestSchema
>;

/**
 * JSON-RPC request for getting push notification config for a task.
 */
export const GetTaskPushNotificationConfigRequestSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The method (always "tasks/pushNotificationConfig/get").
   */
  method: z.literal("tasks/pushNotificationConfig/get"),
  /**
   * Parameters for getting push notification config.
   */
  params: TaskIdParamsSchema,
});
export type GetTaskPushNotificationConfigRequest = z.infer<
  typeof GetTaskPushNotificationConfigRequestSchema
>;

/**
 * JSON-RPC request for resubscribing to a task.
 */
export const TaskResubscriptionRequestSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The method (always "tasks/resubscribe").
   */
  method: z.literal("tasks/resubscribe"),
  /**
   * Parameters for resubscribing to the task.
   */
  params: TaskIdParamsSchema,
});
export type TaskResubscriptionRequest = z.infer<
  typeof TaskResubscriptionRequestSchema
>;

// --- RESPONSES ---
/**
 * JSON-RPC success response for sending a message.
 */
export const SendMessageSuccessResponseSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The result (Task or Message).
   */
  result: z.union([TaskSchema, MessageSchema]),
});
export type SendMessageSuccessResponse = z.infer<
  typeof SendMessageSuccessResponseSchema
>;
export const SendMessageResponseSchema = z.union([
  SendMessageSuccessResponseSchema,
  JSONRPCErrorResponseSchema,
]);
export type SendMessageResponse = z.infer<typeof SendMessageResponseSchema>;

/**
 * JSON-RPC success response for streaming a message.
 */
export const SendStreamingMessageSuccessResponseSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The result (Task, Message, or Event).
   */
  result: z.union([
    TaskSchema,
    MessageSchema,
    TaskStatusUpdateEventSchema,
    TaskArtifactUpdateEventSchema,
  ]),
});
export type SendStreamingMessageSuccessResponse = z.infer<
  typeof SendStreamingMessageSuccessResponseSchema
>;
export const SendStreamingMessageResponseSchema = z.union([
  SendStreamingMessageSuccessResponseSchema,
  JSONRPCErrorResponseSchema,
]);
export type SendStreamingMessageResponse = z.infer<
  typeof SendStreamingMessageResponseSchema
>;

/**
 * JSON-RPC success response for retrieving a task.
 */
export const GetTaskSuccessResponseSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The result (Task).
   */
  result: TaskSchema,
});
export type GetTaskSuccessResponse = z.infer<
  typeof GetTaskSuccessResponseSchema
>;
export const GetTaskResponseSchema = z.union([
  GetTaskSuccessResponseSchema,
  JSONRPCErrorResponseSchema,
]);
export type GetTaskResponse = z.infer<typeof GetTaskResponseSchema>;

/**
 * JSON-RPC success response for canceling a task.
 */
export const CancelTaskSuccessResponseSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The result (Task).
   */
  result: TaskSchema,
});
export type CancelTaskSuccessResponse = z.infer<
  typeof CancelTaskSuccessResponseSchema
>;
export const CancelTaskResponseSchema = z.union([
  CancelTaskSuccessResponseSchema,
  JSONRPCErrorResponseSchema,
]);
export type CancelTaskResponse = z.infer<typeof CancelTaskResponseSchema>;

/**
 * JSON-RPC success response for setting push notification config.
 */
export const SetTaskPushNotificationConfigSuccessResponseSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The result (TaskPushNotificationConfig).
   */
  result: TaskPushNotificationConfigSchema,
});
export type SetTaskPushNotificationConfigSuccessResponse = z.infer<
  typeof SetTaskPushNotificationConfigSuccessResponseSchema
>;
export const SetTaskPushNotificationConfigResponseSchema = z.union([
  SetTaskPushNotificationConfigSuccessResponseSchema,
  JSONRPCErrorResponseSchema,
]);
export type SetTaskPushNotificationConfigResponse = z.infer<
  typeof SetTaskPushNotificationConfigResponseSchema
>;

/**
 * JSON-RPC success response for getting push notification config.
 */
export const GetTaskPushNotificationConfigSuccessResponseSchema = z.object({
  /**
   * The ID of the request.
   */
  id: z.union([z.string(), z.number()]).optional(),
  /**
   * JSON-RPC version (always "2.0").
   */
  jsonrpc: z.literal("2.0"),
  /**
   * The result (TaskPushNotificationConfig).
   */
  result: TaskPushNotificationConfigSchema,
});
export type GetTaskPushNotificationConfigSuccessResponse = z.infer<
  typeof GetTaskPushNotificationConfigSuccessResponseSchema
>;
export const GetTaskPushNotificationConfigResponseSchema = z.union([
  GetTaskPushNotificationConfigSuccessResponseSchema,
  JSONRPCErrorResponseSchema,
]);
export type GetTaskPushNotificationConfigResponse = z.infer<
  typeof GetTaskPushNotificationConfigResponseSchema
>;

// --- UNION TYPES (A2AError, A2ARequest, etc) ---
/**
 * Union of all error types defined in the A2A protocol.
 */
export const A2AErrorSchema = z.union([
  JSONParseErrorSchema,
  InvalidRequestErrorSchema,
  MethodNotFoundErrorSchema,
  InvalidParamsErrorSchema,
  InternalErrorSchema,
  TaskNotFoundErrorSchema,
  TaskNotCancelableErrorSchema,
  PushNotificationNotSupportedErrorSchema,
  UnsupportedOperationErrorSchema,
  ContentTypeNotSupportedErrorSchema,
  InvalidAgentResponseErrorSchema,
]);
export type A2AError = z.infer<typeof A2AErrorSchema>;

/**
 * Union of all request types defined in the A2A protocol.
 */
export const A2ARequestSchema = z.union([
  SendMessageRequestSchema,
  SendStreamingMessageRequestSchema,
  GetTaskRequestSchema,
  CancelTaskRequestSchema,
  SetTaskPushNotificationConfigRequestSchema,
  GetTaskPushNotificationConfigRequestSchema,
  TaskResubscriptionRequestSchema,
]);
export type A2ARequest = z.infer<typeof A2ARequestSchema>;

/**
 *
 */
export type RequestsByMethod = {
  [R in A2ARequest as R["method"]]: R;
};

// --- END ---

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/notification/index.ts`:

```ts
/**
 * Notification client for handling different notification channels
 */
import { PushNotificationConfig } from "../../types/types.ts";

export interface INotificationClient {
  /**
   * Send a notification
   * @param channel - The notification channel (e.g., 'email', 'sms', 'push')
   * @param recipient - The recipient's contact information
   * @param message - The message content
   * @param metadata - Additional metadata for the notification
   */
  sendNotification(
    pushNotificationConfig: PushNotificationConfig
  ): Promise<boolean>;
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/providers/storage/in_memory.ts`:

```ts
import { IStore } from "./index.ts";

/**
 * In-memory implementation of IStore<T>
 */
export class InMemoryStore<T = any> implements IStore<T> {
  private store = new Map<string, { value: T; expiresAt?: number }>();

  async set(key: string, value: T, ttl?: number): Promise<void> {
    let expiresAt: number | undefined = undefined;
    if (ttl && ttl > 0) {
      expiresAt = Date.now() + ttl * 1000;
    }
    this.store.set(key, { value, expiresAt });
  }

  async get(key: string): Promise<T | undefined> {
    const entry = this.store.get(key);
    if (!entry) return undefined;
    if (entry.expiresAt && entry.expiresAt < Date.now()) {
      this.store.delete(key);
      return undefined;
    }
    return entry.value;
  }

  async delete(key: string): Promise<boolean> {
    return this.store.delete(key);
  }

  async has(key: string): Promise<boolean> {
    const entry = this.store.get(key);
    if (!entry) return false;
    if (entry.expiresAt && entry.expiresAt < Date.now()) {
      this.store.delete(key);
      return false;
    }
    return true;
  }

  async clear(): Promise<void> {
    this.store.clear();
  }

  async keys(): Promise<string[]> {
    this.cleanupExpired();
    return Array.from(this.store.keys());
  }

  async values(): Promise<T[]> {
    this.cleanupExpired();
    return Array.from(this.store.values()).map((e) => e.value);
  }

  async entries(): Promise<[string, T][]> {
    this.cleanupExpired();
    return Array.from(this.store.entries()).map(([k, v]) => [k, v.value]);
  }

  /**
   * Remove expired entries
   */
  private cleanupExpired() {
    const now = Date.now();
    for (const [key, entry] of this.store.entries()) {
      if (entry.expiresAt && entry.expiresAt < now) {
        this.store.delete(key);
      }
    }
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/providers/storage/index.ts`:

```ts
/**
 * Store - A generic key-value store interface for task context and state management
 */
export interface IStore<T = any> {
  /**
   * Store a value by key
   * @param key - The key to store the value under
   * @param value - The value to store
   * @param ttl - Optional time-to-live in seconds
   */
  set(key: string, value: T, ttl?: number): Promise<void>;

  /**
   * Get a value by key
   * @param key - The key to retrieve
   * @returns The stored value or undefined if not found
   */
  get(key: string): Promise<T | undefined>;

  /**
   * Delete a value by key
   * @param key - The key to delete
   * @returns true if the key was deleted, false if it didn't exist
   */
  delete(key: string): Promise<boolean>;

  /**
   * Check if a key exists
   * @param key - The key to check
   */
  has?(key: string): Promise<boolean>;

  /**
   * Clear all values from the store
   */
  clear?(): Promise<void>;

  /**
   * Get all keys in the store
   */
  keys?(): Promise<string[]>;

  /**
   * Get all values in the store
   */
  values?(): Promise<T[]>;

  /**
   * Get all entries (key-value pairs) in the store
   */
  entries?(): Promise<[string, T][]>;
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/providers/queue/in_memory.ts`:

```ts
import { IQueue } from "./queue.ts";

/**
 * In-memory implementation of IQueue<T>
 */
export class InMemoryQueue<T> implements IQueue<T> {
  private items: T[] = [];
  private _isClosed: boolean = false;

  // Pending promises for dequeue operations
  private pendingDequeuePromises: Array<(value: T | undefined) => void> = [];

  async dequeue(): Promise<T | undefined> {
    if (this._isClosed) {
      return;
    }
    if (this.items.length === 0) {
      // block and add the promise to the pending list to be resolved when an item is enqueued
      return new Promise<T | undefined>((resolve) => {
        this.pendingDequeuePromises.push(resolve);
      });
    }
    // return the first item
    return this.items.shift()!;
  }

  async enqueue(item: T): Promise<void> {
    this.items.push(item);

    // resolve any pending promises
    this.resolvePendingPromises();
  }

  private resolvePendingPromises() {
    // iterate and resolve any pending promises as long as there are items in the queue
    while (this.pendingDequeuePromises.length > 0 && this.items.length > 0) {
      const resolvePending = this.pendingDequeuePromises.shift()!;
      resolvePending(this.items.shift()!);
    }
  }

  async size(): Promise<number> {
    return this.items.length;
  }

  async isEmpty(): Promise<boolean> {
    return this.items.length === 0;
  }

  async peek(): Promise<T | undefined> {
    if (this.items.length === 0) return undefined;
    return this.items[0];
  }

  // clear the queue and resolve any pending promises with undefined to close the queue
  async close(): Promise<void> {
    this.items = [];
    // iterate and resolve any pending promises as long as there are items in the queue
    while (this.pendingDequeuePromises.length > 0) {
      const resolvePending = this.pendingDequeuePromises.shift()!;
      resolvePending(undefined);
    }
    this.pendingDequeuePromises = [];
    this._isClosed = true;
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/providers/queue/queue.ts`:

```ts
/**
 * Queue - A generic queue interface for task management
 */
export interface IQueue<T> {
  /**
   * Add an item to the queue
   * @param item - The item to enqueue
   */
  enqueue(item: T): Promise<void>;

  /**
   * Remove and return an item from the queue or block until an item is available
   * @returns The dequeued item or undefined if queue is empty
   */
  dequeue(): Promise<T | undefined>;

  /**
   * Get the number of items in the queue
   */
  size?(): Promise<number>;

  /**
   * Check if the queue is empty
   */
  isEmpty?(): Promise<boolean>;

  /**
   * Peek at the next item without removing it
   * @returns The next item or undefined if queue is empty
   */
  peek?(): Promise<T | undefined>;

  /**
   * Free all resources and close the queue
   */
  close?(): Promise<void>;
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/agent/executor.ts`:

```ts
import {
  Task,
  TaskNotFoundError,
  TaskNotCancelableError,
} from "../../types/types.ts";
import { AgentExecutionContext } from "./context.ts";
import type { AgentExecutionResult } from "./types.ts";

export interface IAgentExecutor {
  execute(context: AgentExecutionContext): Promise<AgentExecutionResult>;
  cancel(
    task: Task
  ): Promise<Task | TaskNotFoundError | TaskNotCancelableError>;
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/agent/context.ts`:

```ts
import type { Task, Message, TaskState } from "../../types/types.ts";

import { v4 as uuidv4 } from "uuid";

import type {
  AgentMessageParams,
  AgentRequest,
  AgentTaskParams,
  StreamQueueFactory,
  StreamResult,
} from "./types.ts";
import { AgentTaskStream } from "./stream.ts";

export function requestIsBlocking(request: AgentRequest): boolean {
  return request.params.configuration?.blocking ?? false;
}

export class AgentExecutionContext {
  id: string;
  public request: AgentRequest;
  public streamQueueFactory: StreamQueueFactory;
  public currentTask?: Task;
  public referenceTasks?: Task[];

  private _ensureTask() {
    if (!this.currentTask) {
      throw new Error(
        "taskId not set. Call accept or start first to initiate a task."
      );
    }
  }

  constructor(
    request: AgentRequest,
    streamQueueFactory: StreamQueueFactory,
    task?: Task,
    referenceTasks?: Task[],
    id?: string
  ) {
    this.streamQueueFactory = streamQueueFactory;
    this.request = request;
    this.currentTask = task;
    this.referenceTasks = referenceTasks;
    this.id =
      task?.contextId ||
      this.request.params.message.contextId ||
      id ||
      uuidv4();
  }

  private _createMessage(
    messageParams: AgentMessageParams,
    taskId?: string,
    messageId?: string
  ): Message {
    return {
      kind: "message",
      messageId: messageId || uuidv4(),
      parts: messageParams.parts,
      metadata: messageParams.metadata,
      role: "agent",
      contextId: this.id,
      ...(taskId ? { taskId } : {}),
    };
  }

  private _newOrUpdatedTask(
    taskParams: AgentTaskParams | undefined | null,
    taskState: TaskState,
    taskId?: string
  ): Task {
    let task: Task;
    if (this.currentTask) {
      // update the current task
      task = {
        ...this.currentTask,
        // merge new artifacts with existing artifacts
        artifacts: [
          ...(this.currentTask.artifacts || []),
          ...(taskParams?.artifacts || []),
        ],
        status: {
          ...this.currentTask.status,
          ...(taskParams?.message
            ? {
                message: this._createMessage(
                  taskParams.message,
                  this.currentTask.id
                ),
              }
            : {}),
          state: taskState,
          timestamp: new Date().toISOString(),
        },
        ...(taskParams?.metadata
          ? { metadata: taskParams.metadata }
          : this.currentTask.metadata
          ? { metadata: this.currentTask.metadata }
          : {}),
      };
    } else {
      // create a new task
      taskId = taskId || uuidv4();
      task = {
        kind: "task",
        id: taskId,
        contextId: this.id,
        ...(taskParams?.artifacts ? { artifacts: taskParams.artifacts } : {}),
        status: {
          state: taskState,
          timestamp: new Date().toISOString(),
          ...(taskParams?.message
            ? { message: this._createMessage(taskParams.message, taskId) }
            : {}),
        },
        ...(taskParams?.metadata ? { metadata: taskParams.metadata } : {}),
      };
    }
    return task;
  }

  public setOrUpdateTask(
    taskParams: AgentTaskParams | null | undefined,
    taskState: TaskState,
    taskId?: string
  ): Task {
    let task = this._newOrUpdatedTask(taskParams, taskState, taskId);
    this.currentTask = task;
    return task;
  }

  // Returns an stream result with the current task being set to submitted if not already set
  public async stream(
    cb: (taskStream: AgentTaskStream) => Promise<void> | void,
    taskId?: string,
    initialTaskState: "submitted" | "working" = "submitted"
  ): Promise<StreamResult> {
    // ToDo: check request.
    // set the task to submitted
    let currentTask = this.setOrUpdateTask(null, initialTaskState, taskId);
    let taskStream = new AgentTaskStream(this);
    // call the callback with the task stream to kickoff the stream async (do not await)
    cb(taskStream);
    return { kind: "stream", taskStream, currentTask };
  }

  public async reject(taskParams: AgentTaskParams, taskId?: string) {
    let taskState: TaskState = "rejected";
    let task = this.setOrUpdateTask(taskParams, taskState, taskId);
    return task;
  }

  public async authRequired(taskParams: AgentTaskParams, taskId?: string) {
    let taskState: TaskState = "auth-required";
    let task = this.setOrUpdateTask(taskParams, taskState, taskId);
    return task;
  }

  public async inputRequired(taskParams: AgentTaskParams, taskId?: string) {
    let taskState: TaskState = "input-required";
    let task = this.setOrUpdateTask(taskParams, taskState, taskId);
    return task;
  }

  public async complete(taskParams: AgentTaskParams, taskId?: string) {
    // responding with task mean the task is completed
    let taskState: TaskState = "completed";
    let task = this.setOrUpdateTask(taskParams, taskState, taskId);
    return task;
  }

  public async message(messageParams: AgentMessageParams, messageId?: string) {
    let message = this._createMessage(messageParams, messageId);
    return message;
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/agent/stream.ts`:

```ts
import type {
  AgentArtifactParams,
  AgentStreamQueue,
  AgentTaskParams,
} from "./types.ts";
import { AgentExecutionContext } from "./context.ts";
import type { AgentStreamEvent } from "./types.ts";
import { isJSONRPCError, Task, TaskState } from "../../types/types.ts";

const END_OF_STREAM_EVENT = "end-of-stream";

/**
 * Checks if a task state is final.
 */
export const isFinalTaskState = (state: TaskState) =>
  ["completed", "failed", "canceled", "rejected"].includes(state);

/**
 * Checks if a task state is pending (e.g. input-required, auth-required).
 */
export const isPendingTaskState = (state: TaskState) =>
  ["input-required", "auth-required"].includes(state);

export function isEndOfStream(event: AgentStreamEvent): boolean {
  return !isJSONRPCError(event) && event.kind === END_OF_STREAM_EVENT;
}

export class AgentTaskStream {
  public closed = false;
  public cx: AgentExecutionContext;
  public streamQueue: AgentStreamQueue;

  constructor(cx: AgentExecutionContext) {
    if (!cx.currentTask) {
      throw new Error(
        "Cannot create AgentTaskStream: context has no current task."
      );
    }
    this.cx = cx;
    this.streamQueue = cx.streamQueueFactory();
  }

  private _terminateIfPendingOrFinalState() {
    let task = this.cx.currentTask;
    if (
      task &&
      (isPendingTaskState(task.status.state) ||
        isFinalTaskState(task.status.state))
    ) {
      // close the stream
      this.closed = true;
      // send end of stream event
      this.streamQueue.enqueue({
        kind: END_OF_STREAM_EVENT,
        taskId: task.id,
        contextId: task.contextId,
      });
    }
  }

  private _ensureOpen() {
    if (this.closed) {
      throw new Error("Task stream already terminated.");
    }
  }

  async _sendTaskStatusUpdate(): Promise<void> {
    let task = this.cx.currentTask;
    if (task) {
      let final = isFinalTaskState(task.status.state);
      await this.streamQueue.enqueue({
        kind: "status-update",
        taskId: task.id,
        final,
        contextId: task.contextId,
        status: task.status,
      });
    }
    // TODO: log warning if no task is set
  }

  // ToDo: change stream to always guarantee there is a task to not throw an error
  public getTask(): Task {
    if (!this.cx.currentTask) {
      throw new Error("No task found");
    }
    return this.cx.currentTask;
  }

  public async writeArtifact(
    { artifact, append = false, lastChunk = false }: AgentArtifactParams,
    sendTaskStatusUpdate = true
  ) {
    this._ensureOpen();
    // Add artifact to the current task and set state to 'working'
    // When streaming, artifacts being streamed through artifact updates and are not kept in the current task. only the state is set.
    // update the task with new artifacts
    let task = this.cx.currentTask;
    if (!task) {
      throw new Error("No task find to stream artifacts to");
    }
    // set the task state to 'working' if not already
    if (task.status.state !== "working") {
      this.cx.setOrUpdateTask({}, "working");
      if (sendTaskStatusUpdate) {
        await this._sendTaskStatusUpdate();
      }
    }
    // Send artifact update event
    await this.streamQueue.enqueue({
      kind: "artifact-update",
      taskId: task.id,
      contextId: this.cx.id,
      artifact,
      append,
      lastChunk,
      metadata: artifact.metadata,
    });

    // check and terminate if the task is in a final or pending state
    this._terminateIfPendingOrFinalState();
  }

  // ToDo: use this method to set the task state
  private async _setTaskState(state: TaskState) {
    this._ensureOpen();
    let task = this.cx.currentTask;
    if (!task) {
      throw new Error("No task find to stream artifacts to");
    }
    // if the task state has changed, update it and send the status update
    if (task.status.state !== state) {
      this.cx.setOrUpdateTask({}, state);
      await this._sendTaskStatusUpdate();
    }

    // check and terminate if the task is in a final or pending state
    this._terminateIfPendingOrFinalState();
  }

  public async start(taskParams: AgentTaskParams) {
    this._ensureOpen();
    let task = this.cx.currentTask;
    if (!task) {
      throw new Error("No task find to stream artifacts to");
    }
    // set the task state to 'working' if not already
    if (task.status.state !== "working") {
      this.cx.setOrUpdateTask(taskParams, "working");
      await this._sendTaskStatusUpdate();
    }

    // check and terminate if the task is in a final or pending state
    this._terminateIfPendingOrFinalState();
  }

  public async reject(taskParams: AgentTaskParams) {
    // ensure the stream is open
    this._ensureOpen();
    // set the task state to 'rejected'
    this.cx.setOrUpdateTask(taskParams, "rejected");
    // send the status update
    await this._sendTaskStatusUpdate();

    // check and terminate if the task is in a final or pending state
    this._terminateIfPendingOrFinalState();
  }

  public async authRequired(taskParams: AgentTaskParams) {
    // ensure the stream is open
    this._ensureOpen();
    // set the task state to 'auth-required'
    this.cx.setOrUpdateTask(taskParams, "auth-required");
    // send the status update
    await this._sendTaskStatusUpdate();

    // check and terminate if the task is in a final or pending state
    this._terminateIfPendingOrFinalState();
  }

  public async inputRequired(taskParams: AgentTaskParams) {
    // ensure the stream is open
    this._ensureOpen();
    // set the task state to 'input-required'
    this.cx.setOrUpdateTask(taskParams, "input-required");
    // send the status update
    await this._sendTaskStatusUpdate();

    // check and terminate if the task is in a final or pending state
    this._terminateIfPendingOrFinalState();
  }

  public async complete(taskParams: AgentTaskParams) {
    // responding with task mean the task is completed
    this._ensureOpen();
    this.cx.setOrUpdateTask(taskParams, "completed");
    // send the status update
    await this._sendTaskStatusUpdate();

    // check and terminate if the task is in a final or pending state
    this._terminateIfPendingOrFinalState();
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/agent/types.ts`:

```ts
import type {
  MessageSendParams,
  Part,
  Artifact,
  Message,
  Task,
  A2AError,
  SendStreamingMessageSuccessResponse,
  JSONRPCError,
} from "../../types/types.ts";
import { AgentTaskStream } from "./stream.ts";
import type { IQueue } from "../providers/queue/queue.ts";
import type { IStore } from "../providers/storage/index.ts";

type TaskResult = Task;
type MessageResult = Message;

export type StreamResult = {
  kind: "stream";
  taskStream: AgentTaskStream;
  currentTask: Task;
};
export type AgentExecutionResult =
  | TaskResult
  | MessageResult
  | StreamResult
  | A2AError;

export type AgentRequest = {
  params: MessageSendParams;
  extension?: Record<string, any>;
};

export type EndOfStreamEvent = {
  kind: "end-of-stream";
  taskId?: string;
  contextId?: string;
};

export type AgentStreamEvent =
  | SendStreamingMessageSuccessResponse["result"]
  | JSONRPCError
  | EndOfStreamEvent;

export type AgentStreamQueue = IQueue<AgentStreamEvent>;

// Factory type for creating new IQueue instances
export type StreamQueueFactory = () => AgentStreamQueue;
// Factory type for creating new IStore instances
export type TaskStoreFactory = () => IStore<Task>;

/**
 * Parameters passed to the message
 */
export type AgentMessageParams = {
  parts: Part[];
  metadata?: Record<string, any>;
};

/**
 * Parameters passed to the task related response (reject, start, complete,...)
 */
export type AgentTaskParams = {
  artifacts?: Artifact[];
  message?: AgentMessageParams;
  metadata?: Record<string, any>;
};

export type AgentArtifactParams = {
  artifact: Artifact;
  append?: boolean;
  lastChunk?: boolean;
};

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/agent/request.ts`:

```ts
import { Message, MessageSendConfiguration } from "../../types/types.ts";
import { Task } from "../../types/types.ts";

type PopulatedMessage = Omit<
  Message,
  "taskId" | "referenceTaskIds" | "parts"
> & {
  text: string;
  files: File[];
  data: Array<Record<string, any>>;
};

export function populateMessage(message: Message): PopulatedMessage {
  return {
    ...message,
    text: message.parts
      .filter((part) => part.kind === "text")
      .map((part) => part.text)
      .join("\n"),
    // TODO: implement files
    files: [],
    data: message.parts
      .filter((part) => part.kind === "data")
      .map((part) => part.data),
  };
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/http/hono/hono.ts`:

```ts
import { Hono } from "hono";
import { A2AServer } from "../../index.ts";
import { IAgentExecutor } from "../../agent/executor.ts";
import { jsonRpcBodyParser } from "../../../shared/jsonRpcBodyParser.ts";
import { isJSONRPCError } from "../../../types/types.ts";
import { internalError } from "../../../utils/errors.ts";
import { streamSSE } from "hono/streaming";

export async function createHonoApp({ a2aServer }: { a2aServer: A2AServer }) {
  const app = new Hono();

  // Start the a2a server
  await a2aServer.start();

  // JSON-RPC endpoint
  app.post("/a2a", async (c) => {
    try {
      const bodyText = await c.req.text();
      const parsed = await jsonRpcBodyParser(bodyText);

      // If parser returns a JSONRPCError (has code/message), send JSON-RPC error response
      if (isJSONRPCError(parsed)) {
        return c.json({
          jsonrpc: "2.0",
          id: null,
          error: parsed,
        });
      }
      // Handle request
      const result = await a2aServer.handleRequest(parsed);
      if (result.response) {
        return c.json(result.response);
      } else if (result.stream) {
        const stream = result.stream;
        // Use Hono's StreamSSE helper for SSE
        return streamSSE(c, async (sse) => {
          for await (const jsonRpcResponse of stream) {
            await sse.writeSSE({ data: JSON.stringify(jsonRpcResponse) });
          }
        });
      } else {
        // Unexpected result
        return c.json({
          jsonrpc: "2.0",
          id: parsed?.id || null,
          error: internalError(),
        });
      }
    } catch (err: any) {
      console.error(err);

      return c.json({
        jsonrpc: "2.0",
        id: null,
        error: internalError(),
      });
    }
  });

  // Agent card handler
  app.get("/.well-known/agent.json", async (c) => {
    return c.json(a2aServer.agentCard);
  });

  return app;
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/taskStreamConsumer.ts`:

```ts
/**
 * TaskStreamManager: Manages stream consumption for tasks, ensuring only one consumer per task stream.
 * Allows other callers to tap into the ongoing stream and receive new events as they arrive.
 *
 * - Only the first request for a task starts consuming the stream.
 * - Subsequent requests tap into the live stream and receive new events only.
 * - When the stream ends, all tappers are notified and cleaned up.
 */

import type { AgentStreamEvent, AgentStreamQueue } from "./agent/types.ts";
import type { AgentTaskStream } from "./agent/stream.ts";

/**
 * Represents a tapper/listener for the stream.
 * Each tapper gets an async iterator for new events.
 */
type Tapper<T> = {
  queue: Array<T>;
  resolve: ((value: T | undefined) => void) | undefined;
};

export class TaskStreamConsumer {
  private tappers: Set<Tapper<AgentStreamEvent>> = new Set();
  private consuming: boolean = false;
  // true when the stream is finished
  private finished: boolean = false;
  private readonly streamQueue: AgentStreamQueue;
  private readonly isEndOfStreamEvent: (event: AgentStreamEvent) => boolean;
  private readonly abortSignal?: AbortSignal;

  constructor(
    taskStream: AgentTaskStream,
    isEndOfStreamEvent: (event: AgentStreamEvent) => boolean,
    abortSignal?: AbortSignal
  ) {
    this.streamQueue = taskStream.streamQueue;
    this.isEndOfStreamEvent = isEndOfStreamEvent;
    this.abortSignal = abortSignal;
  }

  /**
   * Adds a new tapper and returns an async generator for it.
   */
  public async *tap(): AsyncGenerator<AgentStreamEvent> {
    const tapper: Tapper<AgentStreamEvent> = {
      queue: [],
      resolve: undefined,
    };
    this.tappers.add(tapper);
    try {
      while (!this.finished) {
        if (tapper.queue.length > 0) {
          const event = tapper.queue.shift()!;
          yield event;
        } else {
          // wait for a new event
          let event = await new Promise<AgentStreamEvent | undefined>(
            (resolve: (value: AgentStreamEvent | undefined) => void) => {
              tapper.resolve = resolve;
            }
          );
          if (event) {
            yield event;
          } else {
            break;
          }
        }
      }
    } finally {
      this.tappers.delete(tapper);
    }
  }

  /**
   * Internal: Consumes the source queue and broadcasts events to tappers.
   */
  public async *consume() {
    // if the stream is finished or already consuming, return
    if (this.consuming || this.finished) return;

    // set the stream as consuming
    this.consuming = true;
    try {
      while (!this.abortSignal?.aborted) {
        const event = await this.streamQueue.dequeue();

        // this will not normally happen since the queue is blocking, but if for any reason the event is undefined the streamQueue is closed
        if (!event) {
          break;
        }

        // if the event is the end of stream, break and do not continue
        if (this.isEndOfStreamEvent(event)) {
          break;
        }

        // ToDo: update the task state in the store, if the event is a task update or artifact update.

        // yield the event
        yield event;

        // Broadcast to all tappers
        for (const tapper of this.tappers) {
          //
          if (tapper.resolve) {
            tapper.resolve(event);
          } else {
            tapper.queue.push(event);
          }
        }
      }
    } catch (err) {
      // ToDo: Notify all tappers of error/end
    } finally {
      // set the stream as finished and notify all tappers and clean up
      this.finished = true;
      for (const tapper of this.tappers) {
        if (tapper.resolve) {
          tapper.resolve(undefined);
        }
      }
      this.tappers.clear();
      this.consuming = false;
    }
  }
}

export class TaskStreamManager {
  // Map of task ID to consumer
  private consumers: Map<string, TaskStreamConsumer> = new Map();

  public getConsumer(taskId: string): TaskStreamConsumer | undefined {
    return this.consumers.get(taskId);
  }

  public createConsumer(
    taskStream: AgentTaskStream,
    isEndOfStreamEvent: (event: AgentStreamEvent) => boolean,
    abortSignal?: AbortSignal
  ): TaskStreamConsumer {
    const task = taskStream.getTask();
    let consumer = this.consumers.get(task.id);
    if (consumer) {
      throw new Error(`Stream for task ${task.id} is already being consumed`);
    }
    consumer = new TaskStreamConsumer(
      taskStream,
      isEndOfStreamEvent,
      abortSignal
    );
    this.consumers.set(task.id, consumer);
    return consumer;
  }

  public tapOrConsume(
    taskStream: AgentTaskStream,
    isEndOfStreamEvent: (event: AgentStreamEvent) => boolean,
    abortSignal?: AbortSignal
  ): AsyncGenerator<AgentStreamEvent> {
    let consumer = this.consumers.get(taskStream.getTask().id);
    if (consumer) {
      // if the consumer is already created tap into it
      return consumer.tap();
    } else {
      // if the consumer is not created, create it and kick off the consumer
      consumer = this.createConsumer(
        taskStream,
        isEndOfStreamEvent,
        abortSignal
      );
      return consumer.consume();
    }
  }

  /**
   * Optionally, remove a consumer when done (cleanup)
   */
  public remove(taskId: string) {
    this.consumers.delete(taskId);
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/server/index.ts`:

```ts
import {
  JSONRPCServer,
  type HandlerResponse,
} from "../shared/jsonRpcServer.ts";
import type { IStore } from "./providers/storage/index.ts";
import type {
  TaskStoreFactory,
  StreamQueueFactory,
  AgentStreamEvent,
  AgentExecutionResult,
  AgentRequest,
} from "./agent/types.ts";
import type { IAgentExecutor } from "./agent/executor.ts";
import { AgentExecutionContext } from "./agent/context.ts";
import { InMemoryStore } from "./providers/storage/in_memory.ts";
import { InMemoryQueue } from "./providers/queue/in_memory.ts";
import {
  internalError,
  invalidAgentResponseError,
  pushNotificationNotSupportedError,
  taskNotFoundError,
} from "../utils/errors.ts";
import {
  CancelTaskRequest,
  GetTaskPushNotificationConfigRequest,
  isJSONRPCError,
  JSONRPCRequest,
  JSONRPCResponse,
  SetTaskPushNotificationConfigRequest,
  Task,
  TaskPushNotificationConfig,
  TaskResubscriptionRequest,
  AgentCard,
} from "../types/types.ts";
import { TaskStreamManager } from "./taskStreamConsumer.ts";
import {
  SendMessageRequest,
  SendStreamingMessageRequest,
} from "../types/types.ts";
import { isEndOfStream } from "./agent/stream.ts";

// Placeholder types for telemetry and logging
// Replace with actual implementations when available
interface TelemetryProvider {
  // Placeholder for telemetry integration
}
interface Logger {
  // Placeholder for logger integration
}

interface A2AServerParams {
  agentExecutor: IAgentExecutor;
  agentCard: AgentCard;
  taskStoreFactory?: TaskStoreFactory;
  queueFactory?: StreamQueueFactory;
  telemetryProvider?: TelemetryProvider;
  logger?: Logger;
}

export class A2AServer {
  private readonly _jsonRpcServer = new JSONRPCServer();
  private readonly _taskStreamManager = new TaskStreamManager();
  private readonly _taskStore: IStore<Task>;
  private readonly _queueFactory: StreamQueueFactory; // Factory for creating new queues
  private readonly _agentExecutor: IAgentExecutor;
  private readonly _telemetryProvider?: TelemetryProvider;
  private readonly _logger?: Logger;
  private _isRunning: boolean = false;
  private readonly _agentCard: AgentCard;

  constructor({
    agentExecutor,
    agentCard,
    taskStoreFactory = () => new InMemoryStore<Task>(),
    queueFactory = () => new InMemoryQueue<AgentStreamEvent>(),
    telemetryProvider,
    logger,
  }: A2AServerParams) {
    this._taskStore = taskStoreFactory();
    this._queueFactory = queueFactory;
    this._agentExecutor = agentExecutor;
    this._telemetryProvider = telemetryProvider;
    this._logger = logger;
    this.registerHandlers();
    this._agentCard = agentCard;
  }

  private async _handleMessage(
    request: SendMessageRequest | SendStreamingMessageRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): Promise<AgentExecutionResult> {
    // Retrieve  and resolve any existing task
    let task: Task | undefined;
    if (request.params.message.taskId) {
      task = await this._taskStore.get(request.params.message.taskId);
      if (!task) {
        return taskNotFoundError(
          `Task ${request.params.message.taskId} not found`
        );
      }
    }

    // Retrieve and resolve any referenced tasks
    let referencedTasks: Task[] | undefined;
    if (request.params.message.referenceTaskIds) {
      referencedTasks = (
        await Promise.all(
          request.params.message.referenceTaskIds.map((taskId) =>
            this._taskStore.get(taskId)
          )
        )
      ).filter((task) => task !== undefined);
    }

    // Create AgentExecutionContext
    const agentRequest: AgentRequest = {
      params: request.params,
      extension,
    };
    const agentExecutionContext = new AgentExecutionContext(
      agentRequest,
      this._queueFactory,
      task,
      referencedTasks
    );

    // Call agentExecutor.execute and handle AgentExecutionResult
    const result = await this._agentExecutor.execute(agentExecutionContext);
    return result;
  }

  private async _handleMessageSend(
    request: SendMessageRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): Promise<JSONRPCResponse> {
    try {
      // Handle the message
      const result = await this._handleMessage(
        request,
        requestAbortSignal,
        extension
      );

      // If JSONRPCError respond with the error
      if (isJSONRPCError(result)) {
        // return an error
        return {
          jsonrpc: "2.0",
          id: request.id,
          error: result,
        };
      }

      // If Task or Message respond with the result
      if (result.kind === "task" || result.kind === "message") {
        // Store the task in the store if it is a task
        if (result.kind === "task") {
          await this._taskStore.set(result.id, result);
        }
        // Respond with the result
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: result,
        };
      }

      // If stream: respond with initial task, consume EventQueue and stream updates
      if (result.kind === "stream") {
        let { taskStream, currentTask } = result;
        if (
          taskStream.getTask().id !== currentTask.id ||
          taskStream.getTask().contextId !== currentTask.contextId
        ) {
          throw new Error(
            "Task mismatch. The task in stream does not match the current task"
          );
        }
        // run the consumer
        const ongoingConsumer = this._taskStreamManager.getConsumer(
          taskStream.getTask().id
        );
        if (!ongoingConsumer) {
          // if there is no consumer, create one and start it
          let consumer = this._taskStreamManager.createConsumer(
            taskStream,
            isEndOfStream,
            requestAbortSignal
          );
          consumer.consume();
        }

        // return the current task as initial response
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: currentTask,
        };
      }
      return {
        jsonrpc: "2.0",
        id: request.id,
        error: invalidAgentResponseError("Unknown result type"),
      };
    } catch (error) {
      return {
        jsonrpc: "2.0",
        id: request.id,
        error: isJSONRPCError(error)
          ? error
          : invalidAgentResponseError(
              error instanceof Error ? error.message : undefined
            ),
      };
    }
  }

  private async *_handleMessageStream(
    request: SendStreamingMessageRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): AsyncGenerator<JSONRPCResponse> {
    try {
      const result = await this._handleMessage(
        request,
        requestAbortSignal,
        extension
      );
      if (isJSONRPCError(result)) {
        // return an error
        yield {
          jsonrpc: "2.0",
          id: request.id,
          error: result,
        };
        return;
      }

      // If Task or Message yield the only result
      if (result.kind === "task" || result.kind === "message") {
        // Store the task in the store if it is a task
        if (result.kind === "task") {
          await this._taskStore.set(result.id, result);
        }
        // return the result
        yield {
          jsonrpc: "2.0",
          id: request.id,
          result: result,
        };
        return;
      }

      // If stream: yield the current task, consume EventQueue and stream updates
      if (result.kind === "stream") {
        let { taskStream, currentTask } = result;
        // yield the current task as initial response
        yield {
          jsonrpc: "2.0",
          id: request.id,
          result: currentTask,
        };

        // if there is no consumer, create one and consume otherwise tap into the existing consumer
        const eventConsumer = this._taskStreamManager.tapOrConsume(
          taskStream,
          isEndOfStream,
          requestAbortSignal
        );

        // yield the events as they come
        for await (const event of eventConsumer) {
          yield {
            jsonrpc: "2.0",
            id: request.id,
            result: event,
          };
        }
      }
    } catch (error) {
      yield {
        jsonrpc: "2.0",
        id: request.id,
        error: isJSONRPCError(error)
          ? error
          : invalidAgentResponseError(
              error instanceof Error ? error.message : undefined
            ),
      };
    }
  }

  private async _handleTaskPushNotificationGet(
    request: GetTaskPushNotificationConfigRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): Promise<JSONRPCResponse> {
    try {
      // Check if the task exists
      const taskId = request.params.id;
      const task = await this._taskStore.get(taskId);
      if (!task) {
        return {
          jsonrpc: "2.0",
          id: request.id,
          error: taskNotFoundError(`Task with ID ${taskId} not found`),
        };
      }

      // This is a placeholder implementation
      // TODO: Implement actual push notification configuration retrieval logic
      return {
        jsonrpc: "2.0",
        id: request.id,
        error: pushNotificationNotSupportedError(),
      };
    } catch (error) {
      return {
        jsonrpc: "2.0",
        id: request.id,
        error: isJSONRPCError(error)
          ? error
          : internalError(error instanceof Error ? error.message : undefined),
      };
    }
  }

  private async _handleTaskPushNotificationSet(
    request: SetTaskPushNotificationConfigRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): Promise<JSONRPCResponse> {
    try {
      // Check if the task exists
      const task = await this._taskStore.get(request.params.taskId);
      if (!task) {
        return {
          jsonrpc: "2.0",
          id: request.id,
          error: taskNotFoundError(
            `Task with ID ${request.params.taskId} not found`
          ),
        };
      }

      // This is a placeholder implementation
      // TODO: Implement actual push notification configuration logic

      // Return the received config as a confirmation
      const result: TaskPushNotificationConfig = {
        taskId: request.params.taskId,
        pushNotificationConfig: {
          ...request.params.pushNotificationConfig,
          // Mask any sensitive credentials in the response
          authentication: request.params.pushNotificationConfig.authentication
            ? {
                schemes:
                  request.params.pushNotificationConfig.authentication.schemes,
                // Omit credentials from response
                credentials: undefined,
              }
            : undefined,
        },
      };

      return {
        jsonrpc: "2.0",
        id: request.id,
        result: result,
      };
    } catch (error) {
      return {
        jsonrpc: "2.0",
        id: request.id,
        error: isJSONRPCError(error)
          ? error
          : internalError(error instanceof Error ? error.message : undefined),
      };
    }
  }

  private async _handleTaskCancel(
    request: CancelTaskRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): Promise<JSONRPCResponse> {
    try {
      // Get the task ID from the request params
      const taskId = request.params?.id;

      // Get the task from the store
      const task = await this._taskStore.get(taskId);
      if (!task) {
        return {
          jsonrpc: "2.0",
          id: request.id,
          error: taskNotFoundError(`Task with ID ${taskId} not found`),
        };
      }

      // Call the agent executor's cancel method
      const result = await this._agentExecutor.cancel(task);

      // Check if the result is an error
      if (isJSONRPCError(result)) {
        return {
          jsonrpc: "2.0",
          id: request.id,
          error: result,
        };
      }

      // Return the updated task
      return {
        jsonrpc: "2.0",
        id: request.id,
        result: result,
      };
    } catch (error) {
      return {
        jsonrpc: "2.0",
        id: request.id,
        error: isJSONRPCError(error)
          ? error
          : invalidAgentResponseError(
              error instanceof Error ? error.message : undefined
            ),
      };
    }
  }

  private async *_handleTaskResubscribe(
    request: TaskResubscriptionRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): AsyncGenerator<JSONRPCResponse> {
    try {
      // Retrieve  and resolve any existing task
      let task: Task | undefined;

      task = await this._taskStore.get(request.params.id);
      if (!task) {
        yield {
          jsonrpc: "2.0",
          id: request.id,
          error: taskNotFoundError(`Task ${request.params.id} not found`),
        };
        return;
      } else {
        const ongoingConsumer = this._taskStreamManager.getConsumer(task.id);
        // if there is no consumer, fail since the task is not active
        if (!ongoingConsumer) {
          yield {
            jsonrpc: "2.0",
            id: request.id,
            error: taskNotFoundError(`Task ${request.params.id} is not active`),
          };
          return;
        }

        // tab into the ongoing consumer and yield the events as they come
        for await (const event of ongoingConsumer.tap()) {
          yield {
            jsonrpc: "2.0",
            id: request.id,
            result: event,
          };
        }
      }
    } catch (error) {
      yield {
        jsonrpc: "2.0",
        id: request.id,
        error: isJSONRPCError(error)
          ? error
          : internalError(error instanceof Error ? error.message : undefined),
      };
    }
  }

  private registerHandlers() {
    // 1. message/send
    this._jsonRpcServer.setRequestHandler(
      "message/send",
      async (request, requestAbortSignal, extension) => {
        const result = await this._handleMessageSend(
          request,
          requestAbortSignal,
          extension
        );
        return { response: result };
      }
    );

    // 2. message/stream
    this._jsonRpcServer.setRequestHandler(
      "message/stream",
      async (request, requestAbortSignal, extension) => {
        const result = await this._handleMessageStream(
          request,
          requestAbortSignal,
          extension
        );
        return { stream: result };
      }
    );

    // 3. tasks/cancel
    this._jsonRpcServer.setRequestHandler(
      "tasks/cancel",
      async (request, requestAbortSignal, extension) => {
        const result = await this._handleTaskCancel(
          request,
          requestAbortSignal,
          extension
        );
        return { response: result };
      }
    );

    // 4. tasks/pushNotification/set
    this._jsonRpcServer.setRequestHandler(
      "tasks/pushNotificationConfig/set",
      async (request, requestAbortSignal, extension) => {
        const result = await this._handleTaskPushNotificationSet(
          request,
          requestAbortSignal,
          extension
        );
        return { response: result };
      }
    );

    // 5. tasks/pushNotification/get
    this._jsonRpcServer.setRequestHandler(
      "tasks/pushNotificationConfig/get",
      async (request, requestAbortSignal, extension) => {
        const result = await this._handleTaskPushNotificationGet(
          request,
          requestAbortSignal,
          extension
        );
        return { response: result };
      }
    );

    // 6. tasks/resubscribe
    this._jsonRpcServer.setRequestHandler(
      "tasks/resubscribe",
      async (request, requestAbortSignal, extension) => {
        const result = await this._handleTaskResubscribe(
          request,
          requestAbortSignal,
          extension
        );
        return { stream: result };
      }
    );
  }

  /**
   * Starts the A2A server. Registers all handlers and performs any startup logic.
   * Extend this method to start HTTP/SSE servers as needed.
   */
  public async start() {
    // Placeholder: Startup logic for server, e.g., HTTP/SSE server initialization
    // Placeholder: Register additional event listeners, health checks, etc.
    // Placeholder: Logging and telemetry
    this.registerHandlers();
    this._isRunning = true;
  }

  /**
   * Expose the JSONRPCServer handleRequest for integration with HTTP layer
   */
  public async handleRequest(
    request: JSONRPCRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): Promise<HandlerResponse> {
    if (!this._isRunning) {
      throw new Error("Server is not running");
    }
    // parse request
    return this._jsonRpcServer.handleRequest(
      request,
      requestAbortSignal,
      extension
    );
  }

  public get agentCard(): AgentCard {
    return this._agentCard;
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/utils/part.ts`:

```ts
import type {
  TextPart,
  FilePart,
  DataPart,
  FileWithBytes,
  FileWithUri,
} from "../types/types.js";

/**
 * Creates a text part with the given content and metadata
 */
export function createTextPart(
  text: string,
  metadata?: Record<string, any>
): TextPart {
  return {
    kind: "text",
    text,
    ...(metadata && { metadata }),
  };
}

/**
 * Creates a file part with the given file data and metadata
 */
export function createFilePart(
  file: FileWithBytes | FileWithUri,
  metadata?: Record<string, any>
): FilePart {
  return {
    kind: "file",
    file,
    ...(metadata && { metadata }),
  };
}

export function isFileWithBytes(
  file: FileWithBytes | FileWithUri
): file is FileWithBytes {
  return "bytes" in file;
}

export function isFileWithUri(
  file: FileWithBytes | FileWithUri
): file is FileWithUri {
  return "uri" in file;
}

/**
 * Creates a data part with the given data and metadata
 */
export function createDataPart(
  data: Record<string, any>,
  metadata?: Record<string, any>
): DataPart {
  return {
    kind: "data",
    data,
    ...(metadata && { metadata }),
  };
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/utils/errors.ts`:

```ts
import { ErrorType } from "../types/types.ts";
import { JSONRPCError } from "../types/types.ts";

//---------- JSONRPC Errors ----------
export function jsonParseError(message?: string, data?: unknown): JSONRPCError {
  return {
    code: ErrorType.JSONParseError,
    message: message ?? "Invalid JSON payload",
    data,
  };
}

export function invalidRequestError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.InvalidRequestError,
    message: message ?? "Request payload validation error",
    data,
  };
}

export function methodNotFoundError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.MethodNotFoundError,
    message: message ?? "Method not found",
    data,
  };
}

export function invalidParamsError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.InvalidParamsError,
    message: message ?? "Invalid parameters",
    data,
  };
}

export function internalError(message?: string, data?: unknown): JSONRPCError {
  return {
    code: ErrorType.InternalError,
    message: message ?? "Internal error",
    data,
  };
}

//---------- A2A Errors ----------

export function taskNotFoundError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.TaskNotFoundError,
    message: message ?? "Task not found",
    data,
  };
}

export function taskNotCancelableError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.TaskNotCancelableError,
    message: message ?? "Task cannot be canceled",
    data,
  };
}

export function pushNotificationNotSupportedError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.PushNotificationNotSupportedError,
    message: message ?? "Push Notification is not supported",
    data,
  };
}

export function unsupportedOperationError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.UnsupportedOperationError,
    message: message ?? "This operation is not supported",
    data,
  };
}

export function contentTypeNotSupportedError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.ContentTypeNotSupportedError,
    message: message ?? "Incompatible content types",
    data,
  };
}

export function invalidAgentResponseError(
  message?: string,
  data?: unknown
): JSONRPCError {
  return {
    code: ErrorType.InvalidAgentResponseError,
    message: message ?? "Invalid agent response",
    data,
  };
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/utils/message.ts`:

```ts
import { v4 as uuidv4 } from "uuid";
import {
  Message,
  MessageRole,
  Part,
  Task,
  FileWithBytes,
  FileWithUri,
  FilePart,
  TextPart,
  DataPart,
} from "../types/types.ts";

export class MessageHandler {
  private message: Message;

  constructor(baseMessage?: Partial<Message>) {
    this.message = {
      kind: "message",
      messageId: baseMessage?.messageId || uuidv4(),
      role: baseMessage?.role || "user",
      parts: baseMessage?.parts ? [...baseMessage.parts] : [],
    };
  }

  withId(messageId: string): MessageHandler {
    this.message.messageId = messageId;
    return this;
  }

  withRole(role: MessageRole): MessageHandler {
    this.message.role = role;
    return this;
  }

  inResponseTo(source: Task | Message): MessageHandler {
    if (source.kind === "task") {
      // Set context and task ID from a Task
      this.message.contextId = source.contextId;
      this.message.taskId = source.id;
    } else if (source.kind === "message") {
      // Set context, task ID, and inResponseTo from a Message
      this.message.contextId = source.contextId;
      this.message.taskId = source.taskId;
    }
    return this;
  }

  withContextId(contextId: string): MessageHandler {
    this.message.contextId = contextId;
    return this;
  }

  withParts(parts: Part[]): MessageHandler {
    this.message.parts = [...parts];
    return this;
  }

  addParts(parts: Part[]): MessageHandler {
    this.message.parts.push(...parts);
    return this;
  }

  addTextPart(text: string, metadata?: Record<string, any>): MessageHandler {
    this.message.parts.push({
      kind: "text",
      text,
      ...(metadata && { metadata }),
    });
    return this;
  }

  addFilePart(
    file: FileWithBytes | FileWithUri,
    metadata?: Record<string, any>
  ): MessageHandler {
    this.message.parts.push({
      kind: "file",
      file,
      ...(metadata && { metadata }),
    });
    return this;
  }

  addDataPart(data: any, metadata?: Record<string, any>): MessageHandler {
    this.message.parts.push({
      kind: "data",
      data,
      ...(metadata && { metadata }),
    });
    return this;
  }

  clearParts(): MessageHandler {
    this.message.parts = [];
    return this;
  }

  withMetadata(metadata: Record<string, any>): MessageHandler {
    this.message.metadata = {
      ...this.message.metadata,
      ...metadata,
    };
    return this;
  }

  getMessage(): Message {
    return { ...this.message };
  }

  getTextParts(): TextPart[] {
    return this.message.parts.filter(
      (
        part
      ): part is {
        kind: "text";
        text: string;
        metadata?: Record<string, any>;
      } => part.kind === "text"
    );
  }

  getText(): string {
    return this.getTextParts()
      .map((part) => part.text)
      .join("\n");
  }

  getFileParts(): FilePart[] {
    return this.message.parts.filter(
      (
        part
      ): part is {
        kind: "file";
        file: FileWithBytes | FileWithUri;
        metadata?: Record<string, any>;
      } => part.kind === "file"
    );
  }

  getFiles(): Array<FileWithBytes | FileWithUri> {
    return this.getFileParts().map((part) => part.file);
  }

  getDataParts(): DataPart[] {
    return this.message.parts.filter(
      (
        part
      ): part is {
        kind: "data";
        data: any;
        metadata?: Record<string, any>;
      } => part.kind === "data"
    );
  }

  getData(): Record<string, any> {
    return this.getDataParts().map((part) => part.data);
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/utils/artifact.ts`:

```ts
import type {
  Artifact,
  Part,
  FileWithBytes,
  FileWithUri,
  FilePart,
  DataPart,
  TextPart,
} from "../types/types.js";

import { v4 as uuidv4 } from "uuid";

export class ArtifactHandler {
  private artifact: Artifact;

  constructor(base?: Partial<Artifact> | Artifact) {
    this.artifact = {
      artifactId: base?.artifactId || uuidv4(),
      name: base?.name,
      description: base?.description,
      metadata: base?.metadata,
      parts: base?.parts || [],
    };
  }

  withId(artifactId: string): ArtifactHandler {
    this.artifact.artifactId = artifactId;
    return this;
  }

  withName(name: string): ArtifactHandler {
    this.artifact.name = name;
    return this;
  }

  withDescription(description: string): ArtifactHandler {
    this.artifact.description = description;
    return this;
  }

  withParts(parts: Part[]): ArtifactHandler {
    this.artifact.parts = [...parts];
    return this;
  }

  addParts(parts: Part[]): ArtifactHandler {
    this.artifact.parts.push(...parts);
    return this;
  }

  clearParts(): ArtifactHandler {
    this.artifact.parts = [];
    return this;
  }

  withMetadata(metadata: Record<string, any>): ArtifactHandler {
    this.artifact.metadata = metadata;
    return this;
  }

  getArtifact(): Artifact {
    return { ...this.artifact };
  }

  getParts(): Part[] {
    return [...this.artifact.parts];
  }

  getTextParts(): Array<TextPart> {
    return this.artifact.parts.filter(
      (part: Part): part is TextPart => part.kind === "text"
    );
  }

  getFileParts(): Array<FilePart> {
    return this.artifact.parts.filter(
      (part: Part): part is FilePart => part.kind === "file"
    );
  }

  getDataParts(): Array<DataPart> {
    return this.artifact.parts.filter(
      (part: Part): part is DataPart => part.kind === "data"
    );
  }

  // Static factory methods
  static fromText(
    text: string,
    metadata?: Record<string, any>
  ): ArtifactHandler {
    return new ArtifactHandler({
      parts: [
        {
          kind: "text",
          text,
          metadata,
        },
      ],
    });
  }

  static fromFile(
    file: FileWithBytes | FileWithUri,
    metadata?: Record<string, any>
  ): ArtifactHandler {
    const name = (file as any).name || "file-artifact";
    return new ArtifactHandler({
      name,
      parts: [
        {
          kind: "file",
          file,
          metadata,
        },
      ],
    });
  }

  static fromData(data: any, metadata?: Record<string, any>): ArtifactHandler {
    return new ArtifactHandler({
      parts: [
        {
          kind: "data",
          data,
          metadata,
        },
      ],
    });
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/utils/task.ts`:

```ts
import { v4 as uuidv4 } from "uuid";
import {
  Task,
  TaskStatus,
  Artifact,
  Message,
  TaskStatusUpdateEvent,
  TaskArtifactUpdateEvent,
  TaskState,
  TaskSchema,
} from "../types/types.js";

export class TaskHandler {
  private task: Partial<Task>;

  constructor(baseTask?: Partial<Omit<Task, "kind">>) {
    this.task = {
      id: baseTask?.id || uuidv4(),
      kind: "task",
      contextId: baseTask?.contextId || undefined,
      status: baseTask?.status
        ? { ...baseTask.status }
        : {
            state: "submitted" as TaskState,
            timestamp: new Date().toISOString(),
          },
      artifacts: baseTask?.artifacts ? [...baseTask.artifacts] : [],
      history: baseTask?.history ? [...baseTask.history] : [],
      metadata: baseTask?.metadata ? { ...baseTask.metadata } : {},
    };
  }

  withId(id: string): TaskHandler {
    this.task.id = id;
    return this;
  }

  withContextId(contextId: string): TaskHandler {
    this.task.contextId = contextId;
    return this;
  }

  withStatus(status: TaskStatus): TaskHandler {
    this.task.status = {
      ...status,
      timestamp: status.timestamp || new Date().toISOString(),
    };
    // update message taskId and contextId if message is set
    if (status.message) {
      this.task.status.message = {
        ...status.message,
        taskId: this.task.id,
        contextId: this.task.contextId,
      };
    }

    return this;
  }

  handleStatusUpdate(event: TaskStatusUpdateEvent): TaskHandler {
    if (event.taskId !== this.task.id) {
      throw new Error(
        `Task ID mismatch for status update: expected ${this.task.id}, got ${event.taskId}`
      );
    }

    return this.withStatus({
      ...event.status,
    });
  }

  withArtifacts(artifacts: Artifact[]): TaskHandler {
    this.task.artifacts = [...artifacts];
    return this;
  }

  upsertArtifact(artifact: Artifact, append: boolean = false): TaskHandler {
    if (!this.task.artifacts) {
      this.task.artifacts = [];
    }

    const existingIndex = this.task.artifacts.findIndex(
      (a: Artifact) => a.artifactId === artifact.artifactId
    );

    // ToDo: find out how the artifacts parts are aggregated if an artifacts has multimodal parts with chunks.
    if (existingIndex !== -1) {
      if (append) {
        this.task.artifacts[existingIndex].parts.push(...artifact.parts);
      } else {
        this.task.artifacts[existingIndex] = artifact;
      }
    } else {
      this.task.artifacts.push(artifact);
    }
    return this;
  }

  handleArtifactUpdate(event: TaskArtifactUpdateEvent): TaskHandler {
    if (event.taskId !== this.task.id) return this;
    return this.upsertArtifact(event.artifact, event.append);
  }

  withMetadata(metadata: Record<string, any>): TaskHandler {
    this.task.metadata = metadata;
    return this;
  }

  withHistory(messages: Message[]): TaskHandler {
    this.task.history = [...messages];
    return this;
  }

  addMessageToHistory(message: Message): TaskHandler {
    if (!this.task.history) {
      this.task.history = [];
    }
    this.task.history.push(message);
    return this;
  }

  getTask(): Task {
    if (!this.task.contextId) {
      throw new Error("Context ID is required for task");
    }
    return TaskSchema.parse(this.task);
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/shared/jsonRpcBodyParser.ts`:

```ts
import { IncomingMessage, ServerResponse } from "http";
import { jsonParseError, invalidRequestError } from "../utils/errors.ts";
import {
  JSONRPCError,
  JSONRPCRequest,
  JSONRPCRequestSchema,
} from "../types/types.ts";

/**
 * Helper to read and parse JSON body from Node.js IncomingMessage
 */
export async function jsonRpcBodyParser(
  body: string
): Promise<JSONRPCRequest | JSONRPCError> {
  if (!body) {
    return jsonParseError("Empty request body");
  }
  try {
    let json = JSON.parse(body);
    // parse the JSON body into a JSONRPCRequest
    let jsonRpcRequest = JSONRPCRequestSchema.safeParse(json);
    if (jsonRpcRequest.success) {
      // If validation succeeds, return the parsed JSON-RPC request
      return jsonRpcRequest.data;
    } else {
      // If validation fails, return a JSONParseError with the validation issues
      return invalidRequestError("Invalid JSON-RPC request");
    }
  } catch (err) {
    return jsonParseError("Invalid json in the body");
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/shared/jsonRpcServer.ts`:

```ts
import {
  JSONRPCRequest,
  JSONRPCResponse,
  ErrorType,
  RequestsByMethod,
} from "../types/types.ts";

export type HandlerResponse = {
  response?: JSONRPCResponse;
  stream?: AsyncGenerator<JSONRPCResponse>;
};

/**
 * Interface for the JSON-RPC Server, outlining its core functionalities.
 */
export interface IJSONRPCServer {
  /**
   * Registers a handler for a specific JSON-RPC method.
   * @param requestSchema The Zod schema defining the specific request, including a literal method name.
   * @param handler The function to execute when a request matching the schema is received.
   */
  setRequestHandler<M extends keyof RequestsByMethod>(
    methodName: M,
    handler: (
      request: RequestsByMethod[M],
      requestAbortSignal?: AbortSignal,
      extension?: Record<string, any>
    ) => Promise<HandlerResponse>
  ): void;

  /**
   * Handles an incoming raw JSON-RPC request string.
   * This is the primary entry point for the server to receive requests.
   * @param rawRequest The raw JSON string of the request.
   * @param requestAbortSignal An optional AbortSignal to cancel the specific request.
   * @returns A promise that resolves to the JSON string of the response, or undefined for notifications.
   */
  handleRequest(
    request: JSONRPCRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): Promise<HandlerResponse>;
}

export class JSONRPCServer implements IJSONRPCServer {
  private _handlers: Map<
    string,
    (
      request: JSONRPCRequest,
      requestAbortSignal?: AbortSignal,
      extension?: Record<string, any>
    ) => Promise<HandlerResponse>
  > = new Map();

  private serverAbortSignal?: AbortSignal;

  public setRequestHandler<M extends keyof RequestsByMethod>(
    methodName: M,
    handler: (
      request: RequestsByMethod[M],
      requestAbortSignal?: AbortSignal,
      extension?: Record<string, any>
    ) => Promise<HandlerResponse>
  ): void {
    // as any is fine since the handler is called with the correct type
    this._handlers.set(methodName, handler as any);
  }

  public async handleRequest(
    request: JSONRPCRequest,
    requestAbortSignal?: AbortSignal,
    extension?: Record<string, any>
  ): Promise<HandlerResponse> {
    try {
      const handler = this._handlers.get(request.method);

      // If no handler is found for the requested method, return a MethodNotFoundError
      if (!handler) {
        return {
          response: {
            jsonrpc: "2.0",
            id: request.id,
            error: {
              code: ErrorType.MethodNotFoundError,
              message: "Method not found",
            },
          },
        };
      }

      // Run the handler and return the result
      return handler(request, requestAbortSignal, extension);
    } catch (error) {
      return {
        response: {
          jsonrpc: "2.0",
          id: request.id,
          error: {
            code: ErrorType.InternalError,
            message: "Internal error",
          },
        },
      };
    }
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/examples/echoStreamAgent/client.ts`:

```ts
import { MessageHandler } from "../../utils/message.ts";
import { A2AClient } from "../../client/a2aClient.ts";

async function run() {
  const client = await A2AClient.getClientFromUrl("http://localhost:3000");

  // print agent card
  console.log("agent card:\n", client.agentCard);

  const userMessage = new MessageHandler()
    .withRole("user")
    .withId("1")
    .addTextPart("Hello. please echo!");

  console.log("user: ", userMessage.getText());
  console.log("user message details:\n", userMessage.getMessage());

  let result: any = client.sendStreamMessage({
    message: userMessage.getMessage(),
  });

  let done = false;

  // continue until the multi turn conversation is completed
  while (!done) {
    // we might reset the stream for new user input, so we use a new variable
    const dataStream = result;
    done = true;
    // Iterate over the stream
    for await (const data of dataStream) {
      if (data) {
        if ("kind" in data) {
          if (data.kind === "message") {
            const agentMessage = new MessageHandler(data);
            console.log("agent message: ", agentMessage.getText());
            console.log("agent message details:\n", agentMessage.getMessage());
          } else if (
            data.kind === "task" &&
            data.status.state === "input-required"
          ) {
            const task = data;
            if (task.status.message) {
              console.log("agent task message:");
              console.log(new MessageHandler(task.status.message).getText());
              console.log("agent task details:\n", task);
            }
            // send user response
            const userResponse = new MessageHandler()
              .withRole("user")
              .withId("3")
              .addTextPart("5")
              .inResponseTo(task);

            console.log("user response: ", userResponse.getText());
            console.log("user response details:\n", userResponse.getMessage());
            result = await client.sendStreamMessage({
              message: userResponse.getMessage(),
            });
            done = false;
          } else {
            console.log("other data", data);
          }
        }
      }
    }
  }
}

await run();

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/examples/echoStreamAgent/server.ts`:

```ts
import { createHonoApp } from "../../server/http/hono/hono.ts";
import { serve } from "@hono/node-server";
import { A2AServer } from "../../server/index.ts";
import { IAgentExecutor } from "../../server/agent/executor.ts";
import { populateMessage } from "../../server/agent/request.ts";
import { taskNotCancelableError } from "../../utils/errors.ts";
import { Part, Task } from "../../types/types.ts";
import { AgentExecutionContext } from "../../server/agent/context.ts";
import { MessageHandler } from "../../utils/message.ts";
import { createTextPart } from "../../utils/part.ts";
import { ArtifactHandler } from "../../utils/artifact.ts";
import { AgentCard } from "../../types/types.ts";

const agentCard: AgentCard = {
  name: "Echo Agent",
  description: "An echo agent that echoes your message.",
  url: "http://localhost:3000/a2a",
  version: "1.0.0",
  capabilities: {
    streaming: true,
    pushNotifications: false,
  },
  skills: [
    {
      id: "echo",
      name: "echo",
      description: "Echoes your message.",
      tags: ["echo"],
    },
  ],
  defaultInputModes: ["text"],
  defaultOutputModes: ["text"],
};

// Dummy executor implementing IAgentExecutor
class EchoAgentExecutor implements IAgentExecutor {
  static messageMemory = new Map<string, string>();

  async execute(context: AgentExecutionContext) {
    let currentTask = context.currentTask;
    let message = populateMessage(context.request.params.message);

    // if no task is set, it is a new message, store message in memory and ask for number of times to echo
    if (!currentTask) {
      const task = await context.inputRequired({
        message: new MessageHandler()
          .withRole("agent")
          .addTextPart(
            "Hello!\nHow many times would you like me to echo your message?"
          )
          .getMessage(),
      });
      // store message in memory to be used for echo
      EchoAgentExecutor.messageMemory.set(task.id, message.text);
      return task;
    }

    // continuation of a paused task

    // check if the current task is waiting for input
    if (currentTask.status.state === "input-required") {
      const echoCount = parseInt(message.text);
      // if not a number, ask for a number
      if (isNaN(echoCount)) {
        const task = await context.inputRequired({
          message: new MessageHandler()
            .withRole("agent")
            .addTextPart("Please enter a valid number.")
            .getMessage(),
        });
        return task;
      }
      // echo message
      return await context.stream(async (stream) => {
        const echoMessage = EchoAgentExecutor.messageMemory.get(currentTask.id);
        if (echoMessage) {
          for (let i = 0; i < echoCount; i++) {
            await stream.writeArtifact({
              artifact: new ArtifactHandler()
                .withId("artifact-1")
                .addParts([createTextPart(echoMessage)])
                .getArtifact(),
              append: true,
              lastChunk: i === echoCount - 1,
            });
            // sleep for 1000ms
            await new Promise((resolve) => setTimeout(resolve, 1000));
          }
          stream.complete({});
        } else {
          stream.reject({
            message: new MessageHandler()
              .withRole("agent")
              .addTextPart("The message to echo was not found.")
              .getMessage(),
          });
        }
      });
    } else {
      return context.message({
        parts: [
          createTextPart(
            `The task is currently in ${currentTask.status.state} state. Not expecting any input in this state.`
          ),
        ],
      });
    }
  }

  async cancel(task: Task) {
    return taskNotCancelableError(`Task ${task.id} cannot be canceled.`);
  }
}

const a2aServer = new A2AServer({
  agentExecutor: new EchoAgentExecutor(),
  agentCard,
});

createHonoApp({ a2aServer })
  .then((app) => {
    serve(
      {
        fetch: app.fetch,
        port: 3000,
      },
      (info) => {
        console.log(`Server is running on http://localhost:${info.port}`);
      }
    );
  })
  .catch((err) => {
    console.error(err);
  });

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/examples/echoAgent/client.ts`:

```ts
import { MessageHandler } from "../../utils/message.ts";
import { A2AClient } from "../../client/a2aClient.ts";

async function run() {
  const client = await A2AClient.getClientFromUrl("http://localhost:3000");

  // print agent card
  console.log("agent card:\n", client.agentCard);

  const userMessage = new MessageHandler()
    .withRole("user")
    .withId("1")
    .addTextPart("Hello. please echo!");

  console.log("user: ", userMessage.getText());
  console.log("user message details:\n", userMessage.getMessage());

  let result = await client.sendMessage({
    message: userMessage.getMessage(),
  });

  if ("kind" in result) {
    if (result.kind === "message") {
      const agentMessage = new MessageHandler(result);
      console.log("agent message: ", agentMessage.getText());
      console.log("agent message details:\n", agentMessage.getMessage());
    } else if (
      result.kind === "task" &&
      result.status.state === "input-required"
    ) {
      const task = result;
      if (task.status.message) {
        console.log("agent task message:");
        console.log(new MessageHandler(task.status.message).getText());
        console.log("agent task details:\n", task);
      }
      // send user response
      const userResponse = new MessageHandler()
        .withRole("user")
        .withId("3")
        .addTextPart("5")
        .inResponseTo(task);

      console.log("user response: ", userResponse.getText());
      console.log("user response details:\n", userResponse.getMessage());
      result = await client.sendMessage({
        message: userResponse.getMessage(),
      });

      if (
        "kind" in result &&
        result.kind === "task" &&
        result.status.state === "completed"
      ) {
        console.log("task completed");
        for (const artifact of result.artifacts || []) {
          console.log(artifact);
          for (const part of artifact.parts) {
            if (part.kind === "text") {
              console.log(part.text);
            }
          }
        }
      } else {
        console.log(result);
      }
    }
  }
}

await run();

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/examples/echoAgent/server.ts`:

```ts
import { createHonoApp } from "../../server/http/hono/hono.ts";
import { serve } from "@hono/node-server";
import { A2AServer } from "../../server/index.ts";
import { IAgentExecutor } from "../../server/agent/executor.ts";
import { taskNotCancelableError } from "../../utils/errors.ts";
import { Part, Task } from "../../types/types.ts";
import { AgentExecutionContext } from "../../server/agent/context.ts";
import { createTextPart } from "../../utils/part.ts";
import { MessageHandler } from "../../utils/message.ts";
import { AgentCard } from "../../types/types.ts";

const agentCard: AgentCard = {
  name: "Echo Agent",
  description: "An echo agent that echoes your message.",
  url: "http://localhost:3000/a2a",
  version: "1.0.0",
  capabilities: {
    streaming: true,
    pushNotifications: false,
  },
  skills: [
    {
      id: "echo",
      name: "echo",
      description: "Echoes your message.",
      tags: ["echo"],
    },
  ],
  defaultInputModes: ["text"],
  defaultOutputModes: ["text"],
};

// Echo executor implementing IAgentExecutor
class EchoAgentExecutor implements IAgentExecutor {
  static messageMemory = new Map<string, string>();

  async execute(context: AgentExecutionContext) {
    let currentTask = context.currentTask;
    let message = new MessageHandler(context.request.params.message);

    // if no task is set, it is a new message, store message in memory and ask for number of times to echo
    if (!currentTask) {
      const task = await context.inputRequired({
        message: {
          parts: [
            createTextPart(
              "Hello!\nHow many times would you like me to echo your message?"
            ),
          ],
        },
      });
      // store message in memory to be used for echo
      EchoAgentExecutor.messageMemory.set(task.id, message.getText());
      return task;
    }

    // continuation of a paused task

    // check if the current task is waiting for input
    if (currentTask.status.state === "input-required") {
      const echoCount = parseInt(message.getText());
      // if not a number, ask for a number
      if (isNaN(echoCount)) {
        const task = await context.inputRequired({
          message: {
            parts: [createTextPart("Please provide a valid number.")],
          },
        });
        return task;
      }
      // echo message
      const echoMessage = EchoAgentExecutor.messageMemory.get(currentTask.id);

      if (!echoMessage) {
        return context.reject({
          message: {
            parts: [createTextPart("The message to echo was not found.")],
          },
        });
      }

      let parts: Part[] = [];
      for (let i = 0; i < echoCount; i++) {
        parts.push(createTextPart(echoMessage));
      }

      return context.complete({
        artifacts: [
          {
            artifactId: "artifact-1",
            parts,
          },
        ],
      });
    }

    // the task is not expecting any input
    return context.message({
      parts: [
        createTextPart(
          `The task is currently in ${currentTask.status.state} state. Not expecting any input in this state.`
        ),
      ],
    });
  }

  async cancel(task: Task) {
    return taskNotCancelableError(`Task ${task.id} cannot be canceled.`);
  }
}

const a2aServer = new A2AServer({
  agentExecutor: new EchoAgentExecutor(),
  agentCard,
});

console.log("Agent card:\n", JSON.stringify(a2aServer.agentCard, null, 2));

createHonoApp({ a2aServer })
  .then((app) => {
    serve(
      {
        fetch: app.fetch,
        port: 3000,
      },
      (info) => {
        console.log(`Server is running on http://localhost:${info.port}`);
      }
    );
  })
  .catch((err) => {
    console.error(err);
  });

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/client/a2aClient.ts`:

```ts
import {
  MessageSendParams,
  SendMessageSuccessResponse,
  GetTaskSuccessResponse,
  CancelTaskSuccessResponse,
  SendStreamingMessageSuccessResponse,
  TaskQueryParams,
  TaskIdParams,
  JSONRPCError,
  JSONRPCRequest,
  RequestsByMethod,
  SendMessageResponseSchema,
  GetTaskResponseSchema,
  CancelTaskResponseSchema,
  SendStreamingMessageResponseSchema,
  SendStreamingMessageResponse,
  AgentCardSchema,
  AgentCard,
} from "../types/types.ts";

export async function fetchAgentCard(
  baseUrl: string,
  path: string = "/.well-known/agent.json"
): Promise<AgentCard> {
  try {
    const agentCardUrl = new URL(path, baseUrl).href;
    const response = await fetch(agentCardUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch agent card: ${response.statusText}`);
    }
    const agentCard = await response.json();
    const parsed = AgentCardSchema.safeParse(agentCard);

    if (!parsed.success) {
      throw new Error(`Invalid agent card: ${parsed.error.message}`);
    }
    return parsed.data;
  } catch (error) {
    throw error;
  }
}

export class A2AClient {
  private _url: string;
  private _agentCard: AgentCard;
  private static idCounter: number = 0;
  private static idCounterBound: number = 1000000;

  constructor(agentCard: AgentCard) {
    // validate agent card
    const parsed = AgentCardSchema.safeParse(agentCard);
    if (!parsed.success) {
      throw new Error(`Invalid agent card: ${parsed.error.message}`);
    }
    this._agentCard = parsed.data;
    this._url = parsed.data.url;
  }

  private static getNewId() {
    return A2AClient.idCounter++ % A2AClient.idCounterBound;
  }

  private async jsonRpcRequest<M extends keyof RequestsByMethod>(
    method: M,
    params: RequestsByMethod[M]["params"]
  ): Promise<Response> {
    const url = this._url;

    const payload: JSONRPCRequest = {
      jsonrpc: "2.0",
      method,
      params,
      id: A2AClient.getNewId(),
    };

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });
    return response;
  }

  async sendMessage(
    params: MessageSendParams
  ): Promise<SendMessageSuccessResponse["result"] | JSONRPCError> {
    const response = await this.jsonRpcRequest("message/send", params);
    const bodyText = await response.text();
    if (!bodyText) {
      throw new Error("Empty response body");
    }
    let json = JSON.parse(bodyText);
    let jsonRpcResponse = SendMessageResponseSchema.parse(json);
    if ("error" in jsonRpcResponse) {
      return jsonRpcResponse.error;
    }
    return jsonRpcResponse.result;
  }

  async getTask(
    params: TaskQueryParams
  ): Promise<GetTaskSuccessResponse["result"] | JSONRPCError> {
    const response = await this.jsonRpcRequest("tasks/get", params);
    const bodyText = await response.text();
    if (!bodyText) {
      throw new Error("Empty response body");
    }
    let json = JSON.parse(bodyText);
    let jsonRpcResponse = GetTaskResponseSchema.parse(json);
    if ("error" in jsonRpcResponse) {
      return jsonRpcResponse.error;
    } else return jsonRpcResponse.result;
  }

  async cancelTask(
    params: TaskIdParams
  ): Promise<CancelTaskSuccessResponse["result"] | JSONRPCError> {
    const response = await this.jsonRpcRequest("tasks/cancel", params);
    const bodyText = await response.text();
    if (!bodyText) {
      throw new Error("Empty response body");
    }
    let json = JSON.parse(bodyText);
    let jsonRpcResponse = CancelTaskResponseSchema.parse(json);
    if ("error" in jsonRpcResponse) {
      return jsonRpcResponse.error;
    } else return jsonRpcResponse.result;
  }

  async *sendStreamMessage(
    params: MessageSendParams
  ): AsyncGenerator<
    SendStreamingMessageSuccessResponse["result"] | JSONRPCError | undefined
  > {
    const url = this._url;
    const payload: JSONRPCRequest = {
      jsonrpc: "2.0",
      method: "message/stream",
      params,
      id: A2AClient.getNewId(),
    };
    const res = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream",
      },
      body: JSON.stringify(payload),
    });

    if (!res.body) throw new Error("No response body for SSE stream");
    for await (const eventText of this.parseSSEStream(res.body)) {
      if (!eventText) continue;
      let parsed: SendStreamingMessageResponse;
      try {
        let json = JSON.parse(eventText);
        parsed = SendStreamingMessageResponseSchema.parse(json);
      } catch (e) {
        // TODO: log warning
        console.warn("Invalid JSON-RPC response", e);
        continue;
      }
      if ("error" in parsed) {
        throw parsed.error;
      }
      if ("result" in parsed) {
        yield parsed.result;
      } else {
        // TODO: log warning
        yield undefined;
      }
    }
  }

  // TODO: refactor the common code with the sendStreamMessage method in a single private method to be used by both methods
  async *resubscribeTask(
    params: TaskIdParams
  ): AsyncGenerator<
    SendStreamingMessageSuccessResponse["result"] | JSONRPCError | undefined
  > {
    const url = this._url;
    const payload: JSONRPCRequest = {
      jsonrpc: "2.0",
      method: "tasks/resubscribe",
      params,
      id: A2AClient.getNewId(),
    };
    const res = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream",
      },
      body: JSON.stringify(payload),
    });

    if (!res.body) throw new Error("No response body for SSE stream");
    for await (const eventText of this.parseSSEStream(res.body)) {
      console.log("resubscribe eventText", eventText);
      if (!eventText) continue;
      let parsed: SendStreamingMessageResponse;
      try {
        let json = JSON.parse(eventText);
        parsed = SendStreamingMessageResponseSchema.parse(json);
      } catch (e) {
        // TODO: log warning
        console.warn("Invalid JSON-RPC response", e);
        continue;
      }
      if ("error" in parsed) {
        throw parsed.error;
      }
      if ("result" in parsed) {
        yield parsed.result;
      } else {
        // TODO: log warning
        yield undefined;
      }
    }
  }

  // Helper to parse SSE events from a ReadableStream
  private async *parseSSEStream(
    stream: ReadableStream<Uint8Array>
  ): AsyncGenerator<string> {
    const decoder = new TextDecoder();
    const reader = stream.getReader();
    let buffer = "";
    try {
      while (true) {
        const { value, done } = await reader.read();

        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        let eventEnd;
        while ((eventEnd = buffer.indexOf("\n\n")) !== -1) {
          const rawEvent = buffer.slice(0, eventEnd);
          buffer = buffer.slice(eventEnd + 2);
          // Only process lines starting with 'data:'
          const dataLine = rawEvent
            .split("\n")
            .find((line) => line.startsWith("data:"));
          if (dataLine) {
            yield dataLine.slice(5).trim();
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  // getter for agent card
  get agentCard(): AgentCard {
    return this._agentCard!;
  }

  static async getClientFromUrl(
    baseUrl: string,
    path: string = "/.well-known/agent.json"
  ): Promise<A2AClient> {
    const agentCard = await fetchAgentCard(baseUrl, path);
    return new A2AClient(agentCard);
  }
}

```

`/Users/hra/Workspace/Code/tesser/front-agent/src/client/curl.requests`:

```requests
curl -X POST http://localhost:3000/a2a \
  -H "Content-Type: application/json" \
  -d @- <<EOF
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "message/send",
  "params": {
    "message": {
      "role": "user",
      "parts": [
        {
          "kind": "text",
          "text": "tell me a joke"
        }
      ],
      "messageId": "9229e770-767c-417b-a0b0-f0741243c589"
    },
    "metadata": {}
  }
}
EOF
```